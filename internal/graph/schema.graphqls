# GraphQL Schema for Knowhow Knowledge Database

scalar DateTime
scalar JSON

# =============================================================================
# TYPES
# =============================================================================

type Entity {
  id: ID!
  type: String!
  name: String!
  content: String
  summary: String
  labels: [String!]!
  contentHash: String
  verified: Boolean!
  confidence: Float!
  source: String!
  sourcePath: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  accessedAt: DateTime!
  accessCount: Int!
  relations: [Relation!]!
}

type Relation {
  id: ID!
  fromId: ID!
  toId: ID!
  relType: String!
  strength: Float!
  source: String!
  createdAt: DateTime!
}

type Template {
  id: ID!
  name: String!
  description: String
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EntitySearchResult {
  entity: Entity!
  matchedChunks: [ChunkMatch!]!
  score: Float!
}

type ChunkMatch {
  content: String!
  headingPath: String
  position: Int!
}

type IngestResult {
  filesProcessed: Int!
  filesSkipped: Int!
  entitiesCreated: Int!
  chunksCreated: Int!
  relationsCreated: Int!
  errors: [String!]!
}

type CheckHashesResult {
  """Paths that need uploading (new or changed content)"""
  needed: [String!]!
}

type Job {
  id: ID!
  type: String!
  status: String!
  progress: Int!
  total: Int!
  result: IngestResult
  error: String
  startedAt: DateTime!
  completedAt: DateTime
  dirPath: String
  pendingFiles: Int
}

type LabelCount {
  label: String!
  count: Int!
}

type TypeCount {
  type: String!
  count: Int!
}

type TokenUsageSummary {
  totalTokens: Int!
  totalCostUSD: Float!
  byOperation: JSON!
  byModel: JSON!
}

type OperationStats {
  count: Int!
  totalTimeMs: Int!
  avgTimeMs: Float!
  minTimeMs: Int!
  maxTimeMs: Int!
  totalInputTokens: Int
  totalOutputTokens: Int
  avgInputTokens: Float
  avgOutputTokens: Float
  minInputTokens: Int
  maxInputTokens: Int
  minOutputTokens: Int
  maxOutputTokens: Int
}

type ServerStats {
  uptimeSeconds: Float!
  embedding: OperationStats
  llmGenerate: OperationStats
  llmStream: OperationStats
  dbQuery: OperationStats
  dbSearch: OperationStats
}

# =============================================================================
# INPUTS
# =============================================================================

input EntityInput {
  type: String!
  name: String!
  content: String
  summary: String
  labels: [String!]
  verified: Boolean
  source: String
  sourcePath: String
  metadata: JSON
}

input EntityUpdate {
  name: String
  content: String
  summary: String
  labels: [String!]
  addLabels: [String!]
  delLabels: [String!]
  verified: Boolean
  metadata: JSON
}

input RelationInput {
  fromId: ID!
  toId: ID!
  relType: String!
  strength: Float
}

input SearchInput {
  query: String!
  labels: [String!]
  types: [String!]
  verifiedOnly: Boolean
  limit: Int
}

input IngestInput {
  labels: [String!]
  extractGraph: Boolean
  dryRun: Boolean
  recursive: Boolean
}

input FileHashInput {
  """Relative or absolute file path"""
  path: String!
  """SHA256 hash of raw file bytes"""
  hash: String!
}

input CheckHashesInput {
  files: [FileHashInput!]!
}

input FileContentInput {
  """File path (used for entity name derivation)"""
  path: String!
  """Raw file content"""
  content: String!
  """SHA256 hash of content"""
  hash: String!
}

input IngestFilesInput {
  files: [FileContentInput!]!
  options: IngestInput
}

# =============================================================================
# QUERIES
# =============================================================================

type Query {
  # Entity operations
  entity(id: ID!): Entity
  entityByName(name: String!): Entity
  entities(type: String, labels: [String!], limit: Int): [Entity!]!

  # Search operations
  search(input: SearchInput!): [EntitySearchResult!]!
  ask(query: String!, input: SearchInput, templateName: String): String!

  # List operations
  labels: [LabelCount!]!
  types: [TypeCount!]!

  # Template operations
  template(name: String!): Template
  templates: [Template!]!

  # Usage tracking
  usageSummary(since: String!): TokenUsageSummary!

  # Job tracking
  jobs: [Job!]!
  job(id: ID!): Job

  # Server statistics (in-memory, resets on restart)
  serverStats: ServerStats!

  # Hash checking for skip-unchanged optimization
  """Check which files need uploading based on content hashes"""
  checkHashes(input: CheckHashesInput!): CheckHashesResult!
}

# =============================================================================
# SUBSCRIPTIONS
# =============================================================================

type AskStreamEvent {
  """Token content from the LLM stream"""
  token: String!
  """True when the stream is complete"""
  done: Boolean!
  """Error message if streaming failed"""
  error: String
}

type Subscription {
  """Stream LLM-synthesized answer token by token"""
  askStream(query: String!, input: SearchInput, templateName: String): AskStreamEvent!
}

# =============================================================================
# MUTATIONS
# =============================================================================

type Mutation {
  # Entity CRUD
  createEntity(input: EntityInput!): Entity!
  updateEntity(id: ID!, input: EntityUpdate!): Entity!
  deleteEntity(id: ID!): Boolean!

  # Relations
  createRelation(input: RelationInput!): Boolean!

  # Ingest operations (server-side file paths)
  ingestFile(filePath: String!, input: IngestInput): Entity!
  ingestDirectory(dirPath: String!, input: IngestInput): IngestResult!
  ingestDirectoryAsync(dirPath: String!, input: IngestInput): Job!

  # Template operations
  createTemplate(name: String!, description: String, content: String!): Template!
  deleteTemplate(name: String!): Boolean!

  # Content-based ingest (for skip-unchanged optimization)
  """Ingest files with content provided directly (used after checkHashes)"""
  ingestFiles(input: IngestFilesInput!): IngestResult!

  """Async version of ingestFiles - returns job immediately, processes in background"""
  ingestFilesAsync(input: IngestFilesInput!): Job!
}
