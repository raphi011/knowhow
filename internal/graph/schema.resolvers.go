package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"path/filepath"

	"github.com/raphaelgruber/memcp-go/internal/models"
	"github.com/raphaelgruber/memcp-go/internal/service"
)

// CreateEntity is the resolver for the createEntity field.
func (r *mutationResolver) CreateEntity(ctx context.Context, input EntityInput) (*Entity, error) {
	// Convert GraphQL input to service input
	modelInput := models.EntityInput{
		Type:       input.Type,
		Name:       input.Name,
		Content:    input.Content,
		Summary:    input.Summary,
		Labels:     input.Labels,
		Verified:   input.Verified,
		SourcePath: input.SourcePath,
		Metadata:   input.Metadata,
	}

	// Set source if provided
	if input.Source != nil {
		source := models.EntitySource(*input.Source)
		modelInput.Source = &source
	}

	result, err := r.entityService.Create(ctx, modelInput)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(result.Entity), nil
}

// UpdateEntity is the resolver for the updateEntity field.
func (r *mutationResolver) UpdateEntity(ctx context.Context, id string, input EntityUpdate) (*Entity, error) {
	modelUpdate := models.EntityUpdate{
		Name:      input.Name,
		Content:   input.Content,
		Summary:   input.Summary,
		Labels:    input.Labels,
		AddLabels: input.AddLabels,
		DelLabels: input.DelLabels,
		Verified:  input.Verified,
		Metadata:  input.Metadata,
	}

	entity, err := r.entityService.Update(ctx, id, modelUpdate)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(entity), nil
}

// DeleteEntity is the resolver for the deleteEntity field.
func (r *mutationResolver) DeleteEntity(ctx context.Context, id string) (bool, error) {
	return r.entityService.Delete(ctx, id)
}

// CreateRelation is the resolver for the createRelation field.
func (r *mutationResolver) CreateRelation(ctx context.Context, input RelationInput) (bool, error) {
	modelInput := models.RelationInput{
		FromID:   input.FromID,
		ToID:     input.ToID,
		RelType:  input.RelType,
		Strength: input.Strength,
	}

	err := r.entityService.CreateRelation(ctx, modelInput)
	if err != nil {
		return false, err
	}
	return true, nil
}

// IngestFile is the resolver for the ingestFile field.
func (r *mutationResolver) IngestFile(ctx context.Context, filePath string, input *IngestInput) (*Entity, error) {
	opts := service.IngestOptions{}
	if input != nil {
		opts.Labels = input.Labels
		if input.ExtractGraph != nil {
			opts.ExtractGraph = *input.ExtractGraph
		}
		if input.DryRun != nil {
			opts.DryRun = *input.DryRun
		}
		if input.Recursive != nil {
			opts.Recursive = *input.Recursive
		}
	}

	// Derive baseDir from parent directory for unique entity IDs
	opts.BaseDir = filepath.Base(filepath.Dir(filePath))

	result, err := r.ingestService.IngestFile(ctx, filePath, opts)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(result.Entity), nil
}

// IngestDirectory is the resolver for the ingestDirectory field.
func (r *mutationResolver) IngestDirectory(ctx context.Context, dirPath string, input *IngestInput) (*IngestResult, error) {
	opts := service.IngestOptions{
		Concurrency: r.jobManager.Concurrency(),
	}
	if input != nil {
		opts.Labels = input.Labels
		if input.ExtractGraph != nil {
			opts.ExtractGraph = *input.ExtractGraph
		}
		if input.DryRun != nil {
			opts.DryRun = *input.DryRun
		}
		if input.Recursive != nil {
			opts.Recursive = *input.Recursive
		}
	}

	result, err := r.ingestService.IngestDirectory(ctx, dirPath, opts)
	if err != nil {
		return nil, err
	}

	return &IngestResult{
		FilesProcessed:   result.FilesProcessed,
		FilesSkipped:     result.FilesSkipped,
		EntitiesCreated:  result.EntitiesCreated,
		ChunksCreated:    result.ChunksCreated,
		RelationsCreated: result.RelationsCreated,
		Errors:           result.Errors,
	}, nil
}

// IngestDirectoryAsync is the resolver for the ingestDirectoryAsync field.
func (r *mutationResolver) IngestDirectoryAsync(ctx context.Context, dirPath string, input *IngestInput) (*Job, error) {
	opts := service.IngestOptions{}
	if input != nil {
		opts.Labels = input.Labels
		if input.ExtractGraph != nil {
			opts.ExtractGraph = *input.ExtractGraph
		}
		if input.DryRun != nil {
			opts.DryRun = *input.DryRun
		}
		if input.Recursive != nil {
			opts.Recursive = *input.Recursive
		}
	}

	job, err := r.ingestService.IngestDirectoryAsync(ctx, r.jobManager, dirPath, opts)
	if err != nil {
		return nil, err
	}

	return serviceJobToGraphQL(job), nil
}

// CreateTemplate is the resolver for the createTemplate field.
func (r *mutationResolver) CreateTemplate(ctx context.Context, name string, description *string, content string) (*Template, error) {
	input := models.TemplateInput{
		Name:        name,
		Description: description,
		Content:     content,
	}

	template, err := r.db.CreateTemplate(ctx, input)
	if err != nil {
		return nil, err
	}

	return templateToGraphQL(template), nil
}

// DeleteTemplate is the resolver for the deleteTemplate field.
func (r *mutationResolver) DeleteTemplate(ctx context.Context, name string) (bool, error) {
	return r.db.DeleteTemplate(ctx, name)
}

// IngestFiles is the resolver for the ingestFiles field.
func (r *mutationResolver) IngestFiles(ctx context.Context, input IngestFilesInput) (*IngestResult, error) {
	opts := service.IngestOptions{
		Concurrency: r.jobManager.Concurrency(),
	}
	if input.Options != nil {
		opts.Labels = input.Options.Labels
		if input.Options.ExtractGraph != nil {
			opts.ExtractGraph = *input.Options.ExtractGraph
		}
		if input.Options.DryRun != nil {
			opts.DryRun = *input.Options.DryRun
		}
	}

	// Convert GraphQL input to service types
	files := make([]service.FileContent, len(input.Files))
	for i, f := range input.Files {
		files[i] = service.FileContent{
			Path:    f.Path,
			Content: f.Content,
			Hash:    f.Hash,
		}
	}

	result, err := r.ingestService.IngestFilesWithContent(ctx, files, input.BaseDir, opts)
	if err != nil {
		return nil, err
	}

	return &IngestResult{
		FilesProcessed:   result.FilesProcessed,
		FilesSkipped:     result.FilesSkipped,
		EntitiesCreated:  result.EntitiesCreated,
		ChunksCreated:    result.ChunksCreated,
		RelationsCreated: result.RelationsCreated,
		Errors:           result.Errors,
	}, nil
}

// IngestFilesAsync is the resolver for the ingestFilesAsync field.
func (r *mutationResolver) IngestFilesAsync(ctx context.Context, input IngestFilesInput) (*Job, error) {
	opts := service.IngestOptions{}
	if input.Options != nil {
		opts.Labels = input.Options.Labels
		if input.Options.ExtractGraph != nil {
			opts.ExtractGraph = *input.Options.ExtractGraph
		}
		if input.Options.DryRun != nil {
			opts.DryRun = *input.Options.DryRun
		}
	}

	// Convert GraphQL input to service types
	files := make([]service.FileContent, len(input.Files))
	for i, f := range input.Files {
		files[i] = service.FileContent{
			Path:    f.Path,
			Content: f.Content,
			Hash:    f.Hash,
		}
	}

	job, err := r.ingestService.IngestFilesWithContentAsync(ctx, r.jobManager, files, input.BaseDir, opts)
	if err != nil {
		return nil, err
	}

	return serviceJobToGraphQL(job), nil
}

// Entity is the resolver for the entity field.
func (r *queryResolver) Entity(ctx context.Context, id string) (*Entity, error) {
	entity, err := r.entityService.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, nil
	}
	return entityToGraphQL(entity), nil
}

// EntityByName is the resolver for the entityByName field.
func (r *queryResolver) EntityByName(ctx context.Context, name string) (*Entity, error) {
	entity, err := r.db.GetEntityByName(ctx, name)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, nil
	}

	// Update access tracking
	if idStr, err := models.RecordIDString(entity.ID); err == nil {
		_ = r.db.UpdateEntityAccess(ctx, idStr) // Best-effort access tracking
	}

	return entityToGraphQL(entity), nil
}

// Entities is the resolver for the entities field.
func (r *queryResolver) Entities(ctx context.Context, typeArg *string, labels []string, limit *int) ([]*Entity, error) {
	entityType := ""
	if typeArg != nil {
		entityType = *typeArg
	}

	lim := 50
	if limit != nil {
		lim = *limit
	}

	entities, err := r.db.ListEntities(ctx, entityType, labels, lim)
	if err != nil {
		return nil, err
	}

	result := make([]*Entity, len(entities))
	for i := range entities {
		result[i] = entityToGraphQL(&entities[i])
	}
	return result, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, input SearchInput) ([]*EntitySearchResult, error) {
	opts := service.SearchOptions{
		Query:  input.Query,
		Labels: input.Labels,
		Types:  input.Types,
	}
	if input.VerifiedOnly != nil {
		opts.VerifiedOnly = *input.VerifiedOnly
	}
	if input.Limit != nil {
		opts.Limit = *input.Limit
	}

	results, err := r.searchService.SearchWithChunks(ctx, opts)
	if err != nil {
		return nil, err
	}

	gqlResults := make([]*EntitySearchResult, len(results))
	for i := range results {
		gqlResults[i] = searchResultToGraphQL(&results[i])
	}
	return gqlResults, nil
}

// Ask is the resolver for the ask field.
func (r *queryResolver) Ask(ctx context.Context, query string, input *SearchInput, templateName *string) (string, error) {
	opts := service.SearchOptions{}
	if input != nil {
		opts.Query = input.Query
		opts.Labels = input.Labels
		opts.Types = input.Types
		if input.VerifiedOnly != nil {
			opts.VerifiedOnly = *input.VerifiedOnly
		}
		if input.Limit != nil {
			opts.Limit = *input.Limit
		}
	}

	if templateName != nil && *templateName != "" {
		return r.searchService.AskWithTemplate(ctx, query, *templateName, opts)
	}

	return r.searchService.Ask(ctx, query, opts)
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context) ([]*LabelCount, error) {
	labels, err := r.db.ListLabels(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*LabelCount, len(labels))
	for i := range labels {
		result[i] = &LabelCount{
			Label: labels[i].Label,
			Count: labels[i].Count,
		}
	}
	return result, nil
}

// Types is the resolver for the types field.
func (r *queryResolver) Types(ctx context.Context) ([]*TypeCount, error) {
	types, err := r.db.ListTypes(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*TypeCount, len(types))
	for i := range types {
		result[i] = &TypeCount{
			Type:  types[i].Type,
			Count: types[i].Count,
		}
	}
	return result, nil
}

// Template is the resolver for the template field.
func (r *queryResolver) Template(ctx context.Context, name string) (*Template, error) {
	template, err := r.db.GetTemplate(ctx, name)
	if err != nil {
		return nil, err
	}
	if template == nil {
		return nil, nil
	}
	return templateToGraphQL(template), nil
}

// Templates is the resolver for the templates field.
func (r *queryResolver) Templates(ctx context.Context) ([]*Template, error) {
	templates, err := r.db.ListTemplates(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*Template, len(templates))
	for i := range templates {
		result[i] = templateToGraphQL(&templates[i])
	}
	return result, nil
}

// UsageSummary is the resolver for the usageSummary field.
func (r *queryResolver) UsageSummary(ctx context.Context, since string) (*TokenUsageSummary, error) {
	summary, err := r.db.GetTokenUsageSummary(ctx, since)
	if err != nil {
		return nil, err
	}

	// Convert map[string]int to map[string]any for GraphQL JSON scalar
	byOperation := make(map[string]any)
	for k, v := range summary.ByOperation {
		byOperation[k] = v
	}

	byModel := make(map[string]any)
	for k, v := range summary.ByModel {
		byModel[k] = v
	}

	return &TokenUsageSummary{
		TotalTokens:  summary.TotalTokens,
		TotalCostUSD: summary.TotalCostUSD,
		ByOperation:  byOperation,
		ByModel:      byModel,
	}, nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context) ([]*Job, error) {
	jobs := r.jobManager.ListJobs()
	result := make([]*Job, len(jobs))
	for i, j := range jobs {
		result[i] = serviceJobToGraphQL(j)
	}
	return result, nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id string) (*Job, error) {
	job := r.jobManager.GetJob(id)
	if job == nil {
		return nil, nil
	}
	return serviceJobToGraphQL(job), nil
}

// ServerStats is the resolver for the serverStats field.
func (r *queryResolver) ServerStats(ctx context.Context) (*ServerStats, error) {
	snap := r.metrics.Snapshot()
	return metricsSnapshotToGraphQL(snap), nil
}

// CheckHashes is the resolver for the checkHashes field.
func (r *queryResolver) CheckHashes(ctx context.Context, input CheckHashesInput) (*CheckHashesResult, error) {
	// Convert GraphQL input to service types
	files := make([]service.FileHash, len(input.Files))
	for i, f := range input.Files {
		files[i] = service.FileHash{
			Path: f.Path,
			Hash: f.Hash,
		}
	}

	// Query which files need uploading
	needed, err := r.ingestService.CheckHashes(ctx, files)
	if err != nil {
		return nil, err
	}

	return &CheckHashesResult{
		Needed: needed,
	}, nil
}

// AskStream is the resolver for the askStream field.
func (r *subscriptionResolver) AskStream(ctx context.Context, query string, input *SearchInput, templateName *string) (<-chan *AskStreamEvent, error) {
	// Template-based streaming not yet implemented
	if templateName != nil {
		return nil, fmt.Errorf("streaming with templates not yet supported, use regular ask query")
	}

	// Convert GraphQL input to service options
	opts := service.SearchOptions{Query: query}
	if input != nil {
		if len(input.Labels) > 0 {
			opts.Labels = input.Labels
		}
		if len(input.Types) > 0 {
			opts.Types = input.Types
		}
		if input.VerifiedOnly != nil {
			opts.VerifiedOnly = *input.VerifiedOnly
		}
		if input.Limit != nil {
			opts.Limit = *input.Limit
		}
	}

	// Create channel for streaming events (buffered to avoid blocking LLM)
	eventChan := make(chan *AskStreamEvent, 100)

	// Start streaming in goroutine
	go func() {
		defer close(eventChan)

		err := r.searchService.AskStream(ctx, query, opts, func(token string) error {
			// Check if context was canceled (client disconnected)
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:
			}

			// Send token event
			select {
			case eventChan <- &AskStreamEvent{Token: token, Done: false}:
				return nil
			case <-ctx.Done():
				return ctx.Err()
			}
		})

		// Send completion event
		if err != nil {
			errMsg := err.Error()
			select {
			case eventChan <- &AskStreamEvent{Token: "", Done: true, Error: &errMsg}:
			case <-ctx.Done():
			}
		} else {
			select {
			case eventChan <- &AskStreamEvent{Token: "", Done: true}:
			case <-ctx.Done():
			}
		}
	}()

	return eventChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
