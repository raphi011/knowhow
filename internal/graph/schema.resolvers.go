package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/raphaelgruber/memcp-go/internal/models"
	"github.com/raphaelgruber/memcp-go/internal/service"
)

// =============================================================================
// MUTATIONS
// =============================================================================

// CreateEntity is the resolver for the createEntity field.
func (r *mutationResolver) CreateEntity(ctx context.Context, input EntityInput) (*Entity, error) {
	// Convert GraphQL input to service input
	modelInput := models.EntityInput{
		Type:       input.Type,
		Name:       input.Name,
		Content:    input.Content,
		Summary:    input.Summary,
		Labels:     input.Labels,
		Verified:   input.Verified,
		SourcePath: input.SourcePath,
		Metadata:   input.Metadata,
	}

	// Set source if provided
	if input.Source != nil {
		source := models.EntitySource(*input.Source)
		modelInput.Source = &source
	}

	entity, err := r.entityService.Create(ctx, modelInput)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(entity), nil
}

// UpdateEntity is the resolver for the updateEntity field.
func (r *mutationResolver) UpdateEntity(ctx context.Context, id string, input EntityUpdate) (*Entity, error) {
	modelUpdate := models.EntityUpdate{
		Name:      input.Name,
		Content:   input.Content,
		Summary:   input.Summary,
		Labels:    input.Labels,
		AddLabels: input.AddLabels,
		DelLabels: input.DelLabels,
		Verified:  input.Verified,
		Metadata:  input.Metadata,
	}

	entity, err := r.entityService.Update(ctx, id, modelUpdate)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(entity), nil
}

// DeleteEntity is the resolver for the deleteEntity field.
func (r *mutationResolver) DeleteEntity(ctx context.Context, id string) (bool, error) {
	return r.entityService.Delete(ctx, id)
}

// CreateRelation is the resolver for the createRelation field.
func (r *mutationResolver) CreateRelation(ctx context.Context, input RelationInput) (bool, error) {
	modelInput := models.RelationInput{
		FromID:   input.FromID,
		ToID:     input.ToID,
		RelType:  input.RelType,
		Strength: input.Strength,
	}

	err := r.entityService.CreateRelation(ctx, modelInput)
	if err != nil {
		return false, err
	}
	return true, nil
}

// IngestFile is the resolver for the ingestFile field.
func (r *mutationResolver) IngestFile(ctx context.Context, filePath string, input *IngestInput) (*Entity, error) {
	opts := service.IngestOptions{}
	if input != nil {
		opts.Labels = input.Labels
		if input.ExtractGraph != nil {
			opts.ExtractGraph = *input.ExtractGraph
		}
		if input.DryRun != nil {
			opts.DryRun = *input.DryRun
		}
		if input.Recursive != nil {
			opts.Recursive = *input.Recursive
		}
	}

	entity, err := r.ingestService.IngestFile(ctx, filePath, opts)
	if err != nil {
		return nil, err
	}

	return entityToGraphQL(entity), nil
}

// IngestDirectory is the resolver for the ingestDirectory field.
func (r *mutationResolver) IngestDirectory(ctx context.Context, dirPath string, input *IngestInput) (*IngestResult, error) {
	opts := service.IngestOptions{}
	if input != nil {
		opts.Labels = input.Labels
		if input.ExtractGraph != nil {
			opts.ExtractGraph = *input.ExtractGraph
		}
		if input.DryRun != nil {
			opts.DryRun = *input.DryRun
		}
		if input.Recursive != nil {
			opts.Recursive = *input.Recursive
		}
	}

	result, err := r.ingestService.IngestDirectory(ctx, dirPath, opts)
	if err != nil {
		return nil, err
	}

	return &IngestResult{
		FilesProcessed:   result.FilesProcessed,
		EntitiesCreated:  result.EntitiesCreated,
		ChunksCreated:    result.ChunksCreated,
		RelationsCreated: result.RelationsCreated,
		Errors:           result.Errors,
	}, nil
}

// CreateTemplate is the resolver for the createTemplate field.
func (r *mutationResolver) CreateTemplate(ctx context.Context, name string, description *string, content string) (*Template, error) {
	input := models.TemplateInput{
		Name:        name,
		Description: description,
		Content:     content,
	}

	template, err := r.db.CreateTemplate(ctx, input)
	if err != nil {
		return nil, err
	}

	return templateToGraphQL(template), nil
}

// DeleteTemplate is the resolver for the deleteTemplate field.
func (r *mutationResolver) DeleteTemplate(ctx context.Context, name string) (bool, error) {
	return r.db.DeleteTemplate(ctx, name)
}

// =============================================================================
// QUERIES
// =============================================================================

// Entity is the resolver for the entity field.
func (r *queryResolver) Entity(ctx context.Context, id string) (*Entity, error) {
	entity, err := r.entityService.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, nil
	}
	return entityToGraphQL(entity), nil
}

// EntityByName is the resolver for the entityByName field.
func (r *queryResolver) EntityByName(ctx context.Context, name string) (*Entity, error) {
	entity, err := r.db.GetEntityByName(ctx, name)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, nil
	}

	// Update access tracking
	if idStr, err := models.RecordIDString(entity.ID); err == nil {
		_ = r.db.UpdateEntityAccess(ctx, idStr) // Best-effort access tracking
	}

	return entityToGraphQL(entity), nil
}

// Entities is the resolver for the entities field.
func (r *queryResolver) Entities(ctx context.Context, typeArg *string, labels []string, limit *int) ([]*Entity, error) {
	entityType := ""
	if typeArg != nil {
		entityType = *typeArg
	}

	lim := 50
	if limit != nil {
		lim = *limit
	}

	entities, err := r.db.ListEntities(ctx, entityType, labels, lim)
	if err != nil {
		return nil, err
	}

	result := make([]*Entity, len(entities))
	for i := range entities {
		result[i] = entityToGraphQL(&entities[i])
	}
	return result, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, input SearchInput) ([]*EntitySearchResult, error) {
	opts := service.SearchOptions{
		Query:  input.Query,
		Labels: input.Labels,
		Types:  input.Types,
	}
	if input.VerifiedOnly != nil {
		opts.VerifiedOnly = *input.VerifiedOnly
	}
	if input.Limit != nil {
		opts.Limit = *input.Limit
	}

	results, err := r.searchService.SearchWithChunks(ctx, opts)
	if err != nil {
		return nil, err
	}

	gqlResults := make([]*EntitySearchResult, len(results))
	for i := range results {
		gqlResults[i] = searchResultToGraphQL(&results[i])
	}
	return gqlResults, nil
}

// Ask is the resolver for the ask field.
func (r *queryResolver) Ask(ctx context.Context, query string, input *SearchInput, templateName *string) (string, error) {
	opts := service.SearchOptions{}
	if input != nil {
		opts.Query = input.Query
		opts.Labels = input.Labels
		opts.Types = input.Types
		if input.VerifiedOnly != nil {
			opts.VerifiedOnly = *input.VerifiedOnly
		}
		if input.Limit != nil {
			opts.Limit = *input.Limit
		}
	}

	if templateName != nil && *templateName != "" {
		return r.searchService.AskWithTemplate(ctx, query, *templateName, opts)
	}

	return r.searchService.Ask(ctx, query, opts)
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context) ([]*LabelCount, error) {
	labels, err := r.db.ListLabels(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*LabelCount, len(labels))
	for i := range labels {
		result[i] = &LabelCount{
			Label: labels[i].Label,
			Count: labels[i].Count,
		}
	}
	return result, nil
}

// Types is the resolver for the types field.
func (r *queryResolver) Types(ctx context.Context) ([]*TypeCount, error) {
	types, err := r.db.ListTypes(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*TypeCount, len(types))
	for i := range types {
		result[i] = &TypeCount{
			Type:  types[i].Type,
			Count: types[i].Count,
		}
	}
	return result, nil
}

// Template is the resolver for the template field.
func (r *queryResolver) Template(ctx context.Context, name string) (*Template, error) {
	template, err := r.db.GetTemplate(ctx, name)
	if err != nil {
		return nil, err
	}
	if template == nil {
		return nil, nil
	}
	return templateToGraphQL(template), nil
}

// Templates is the resolver for the templates field.
func (r *queryResolver) Templates(ctx context.Context) ([]*Template, error) {
	templates, err := r.db.ListTemplates(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*Template, len(templates))
	for i := range templates {
		result[i] = templateToGraphQL(&templates[i])
	}
	return result, nil
}

// UsageSummary is the resolver for the usageSummary field.
func (r *queryResolver) UsageSummary(ctx context.Context, since string) (*TokenUsageSummary, error) {
	summary, err := r.db.GetTokenUsageSummary(ctx, since)
	if err != nil {
		return nil, err
	}

	// Convert map[string]int to map[string]any for GraphQL JSON scalar
	byOperation := make(map[string]any)
	for k, v := range summary.ByOperation {
		byOperation[k] = v
	}

	byModel := make(map[string]any)
	for k, v := range summary.ByModel {
		byModel[k] = v
	}

	return &TokenUsageSummary{
		TotalTokens:  summary.TotalTokens,
		TotalCostUSD: summary.TotalCostUSD,
		ByOperation:  byOperation,
		ByModel:      byModel,
	}, nil
}

// =============================================================================
// ROOT RESOLVERS
// =============================================================================

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// =============================================================================
// HELPERS
// =============================================================================

// entityToGraphQL converts a models.Entity to a GraphQL Entity.
func entityToGraphQL(e *models.Entity) *Entity {
	if e == nil {
		return nil
	}

	idStr, err := models.RecordIDString(e.ID)
	if err != nil {
		idStr = fmt.Sprintf("%v", e.ID.ID)
	}

	var sourcePath *string
	if e.SourcePath != nil {
		sourcePath = e.SourcePath
	}

	return &Entity{
		ID:          idStr,
		Type:        e.Type,
		Name:        e.Name,
		Content:     e.Content,
		Summary:     e.Summary,
		Labels:      e.Labels,
		Verified:    e.Verified,
		Confidence:  e.Confidence,
		Source:      string(e.Source),
		SourcePath:  sourcePath,
		Metadata:    e.Metadata,
		CreatedAt:   e.CreatedAt,
		UpdatedAt:   e.UpdatedAt,
		AccessedAt:  e.Accessed,
		AccessCount: e.AccessCount,
		Relations:   []Relation{}, // Relations loaded separately if needed
	}
}

// templateToGraphQL converts a models.Template to a GraphQL Template.
func templateToGraphQL(t *models.Template) *Template {
	if t == nil {
		return nil
	}

	idStr, err := models.RecordIDString(t.ID)
	if err != nil {
		idStr = fmt.Sprintf("%v", t.ID.ID)
	}

	return &Template{
		ID:          idStr,
		Name:        t.Name,
		Description: t.Description,
		Content:     t.Content,
		CreatedAt:   t.CreatedAt,
		UpdatedAt:   t.UpdatedAt,
	}
}

// searchResultToGraphQL converts a models.EntitySearchResult to GraphQL.
func searchResultToGraphQL(r *models.EntitySearchResult) *EntitySearchResult {
	if r == nil {
		return nil
	}

	entity := entityToGraphQL(&r.Entity)

	chunks := make([]ChunkMatch, len(r.MatchedChunks))
	for i, chunk := range r.MatchedChunks {
		chunks[i] = ChunkMatch{
			Content:     chunk.Content,
			HeadingPath: chunk.HeadingPath,
			Position:    chunk.Position,
		}
	}

	return &EntitySearchResult{
		Entity:        *entity,
		MatchedChunks: chunks,
		Score:         r.Score,
	}
}
