---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/models/entity.go
  - internal/models/episode.go
  - internal/models/procedure.go
  - internal/models/relation.go
  - internal/config/config.go
  - internal/config/logging.go
autonomous: true

must_haves:
  truths:
    - "Go module compiles with all dependencies resolved"
    - "Data models serialize to JSON with snake_case field names"
    - "Log output appears in both stderr and configured log file"
    - "Environment variables are loaded with Python-matching defaults"
  artifacts:
    - path: "go.mod"
      provides: "Module definition with dependencies"
      contains: "github.com/modelcontextprotocol/go-sdk"
    - path: "internal/models/entity.go"
      provides: "Entity struct with JSON tags"
      contains: "type Entity struct"
    - path: "internal/models/episode.go"
      provides: "Episode struct with JSON tags"
      contains: "type Episode struct"
    - path: "internal/models/procedure.go"
      provides: "Procedure and ProcedureStep structs"
      contains: "type Procedure struct"
    - path: "internal/models/relation.go"
      provides: "Relation struct with JSON tags"
      contains: "type Relation struct"
    - path: "internal/config/config.go"
      provides: "Configuration loading from environment"
      contains: "func Load()"
    - path: "internal/config/logging.go"
      provides: "Dual-output logger setup"
      contains: "slogmulti.Fanout"
  key_links:
    - from: "internal/config/logging.go"
      to: "log/slog"
      via: "slog.New with multi-handler"
      pattern: "slog\\.New.*Fanout"
---

<objective>
Initialize Go module with all dependencies, create data model structs matching Python schema, and establish dual-output structured logging.

Purpose: Foundation infrastructure for all subsequent phases - models define data contracts, config loads environment, logging enables debugging.
Output: Compiling Go module with models, config, and logging packages.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md

# Python models to port
@memcp/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module with dependencies</name>
  <files>go.mod, go.sum</files>
  <action>
Create Go module and install all dependencies from RESEARCH.md:

```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go
go mod init github.com/raphaelgruber/memcp-go

# Core dependencies (exact versions from research)
go get github.com/modelcontextprotocol/go-sdk@v1.2.0
go get github.com/surrealdb/surrealdb.go@v1.2.0
go get github.com/ollama/ollama/api

# Supporting dependencies
go get github.com/samber/slog-multi
go get github.com/stretchr/testify
go get github.com/joho/godotenv
```

Create directory structure:
```bash
mkdir -p internal/models internal/config internal/db internal/embedding cmd/memcp
```
  </action>
  <verify>
`go mod tidy` succeeds without errors
`cat go.mod` shows all dependencies
  </verify>
  <done>go.mod exists with modelcontextprotocol/go-sdk, surrealdb.go, ollama/api, slog-multi dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create data model structs</name>
  <files>internal/models/entity.go, internal/models/episode.go, internal/models/procedure.go, internal/models/relation.go</files>
  <action>
Create model structs matching Python schema exactly. Use JSON tags with snake_case.

**internal/models/entity.go:**
```go
package models

import "time"

// Entity represents a memory entity in the knowledge graph.
// Matches Python memcp/models.py EntityResult.
type Entity struct {
    ID             string    `json:"id"`
    Type           string    `json:"type,omitempty"`
    Labels         []string  `json:"labels,omitempty"`
    Content        string    `json:"content"`
    Embedding      []float32 `json:"embedding,omitempty"`
    Confidence     float64   `json:"confidence,omitempty"`
    Source         *string   `json:"source,omitempty"`
    DecayWeight    float64   `json:"decay_weight,omitempty"`
    Context        *string   `json:"context,omitempty"`
    Importance     float64   `json:"importance,omitempty"`
    UserImportance *float64  `json:"user_importance,omitempty"`
    Created        time.Time `json:"created,omitempty"`
    Accessed       time.Time `json:"accessed,omitempty"`
    AccessCount    int       `json:"access_count,omitempty"`
}

// SearchResult wraps entity search results.
type SearchResult struct {
    Entities []Entity `json:"entities"`
    Count    int      `json:"count"`
    Summary  *string  `json:"summary,omitempty"`
}
```

**internal/models/episode.go:**
```go
package models

import "time"

// Episode represents an episodic memory (conversation segment).
type Episode struct {
    ID             string         `json:"id"`
    Content        string         `json:"content"`
    Summary        *string        `json:"summary,omitempty"`
    Embedding      []float32      `json:"embedding,omitempty"`
    Metadata       map[string]any `json:"metadata,omitempty"`
    Timestamp      time.Time      `json:"timestamp,omitempty"`
    Context        *string        `json:"context,omitempty"`
    Created        time.Time      `json:"created,omitempty"`
    Accessed       time.Time      `json:"accessed,omitempty"`
    AccessCount    int            `json:"access_count,omitempty"`
    LinkedEntities int            `json:"linked_entities,omitempty"`
    Entities       []Entity       `json:"entities,omitempty"`
}

// EpisodeSearchResult wraps episode search results.
type EpisodeSearchResult struct {
    Episodes []Episode `json:"episodes"`
    Count    int       `json:"count"`
}
```

**internal/models/procedure.go:**
```go
package models

import "time"

// ProcedureStep represents a single step within a procedure.
type ProcedureStep struct {
    Order    int    `json:"order"`
    Content  string `json:"content"`
    Optional bool   `json:"optional,omitempty"`
}

// Procedure represents a procedural memory (workflow/process).
type Procedure struct {
    ID          string          `json:"id"`
    Name        string          `json:"name"`
    Description string          `json:"description"`
    Steps       []ProcedureStep `json:"steps"`
    Embedding   []float32       `json:"embedding,omitempty"`
    Context     *string         `json:"context,omitempty"`
    Labels      []string        `json:"labels,omitempty"`
    Created     time.Time       `json:"created,omitempty"`
    Accessed    time.Time       `json:"accessed,omitempty"`
    AccessCount int             `json:"access_count,omitempty"`
}

// ProcedureSearchResult wraps procedure search results.
type ProcedureSearchResult struct {
    Procedures []Procedure `json:"procedures"`
    Count      int         `json:"count"`
}
```

**internal/models/relation.go:**
```go
package models

import "time"

// Relation represents a relationship between entities.
type Relation struct {
    From    string    `json:"from"`
    To      string    `json:"to"`
    RelType string    `json:"rel_type"`
    Weight  float64   `json:"weight,omitempty"`
    Created time.Time `json:"created,omitempty"`
}
```

CRITICAL: Use `[]float32` for embeddings (Ollama returns float32, SurrealDB accepts float32). Use pointer types for optional fields (`*string`, `*float64`).
  </action>
  <verify>
`go build ./internal/models/...` compiles without errors
  </verify>
  <done>All four model files exist and compile, JSON tags match Python field names</done>
</task>

<task type="auto">
  <name>Task 3: Create configuration and logging</name>
  <files>internal/config/config.go, internal/config/logging.go</files>
  <action>
**internal/config/config.go:**
```go
package config

import (
    "log/slog"
    "os"
    "strings"
)

// Config holds all configuration values.
type Config struct {
    // SurrealDB connection
    SurrealDBURL       string
    SurrealDBNamespace string
    SurrealDBDatabase  string
    SurrealDBUser      string
    SurrealDBPass      string
    SurrealDBAuthLevel string

    // Ollama embedding
    OllamaHost     string
    EmbeddingModel string

    // Logging
    LogFile  string
    LogLevel slog.Level

    // Context detection
    DefaultContext string
    ContextFromCWD bool
}

// Load reads configuration from environment variables.
// Defaults match Python memcp/db.py exactly.
func Load() Config {
    return Config{
        // SurrealDB (matching Python defaults)
        SurrealDBURL:       getEnv("SURREALDB_URL", "ws://localhost:8000/rpc"),
        SurrealDBNamespace: getEnv("SURREALDB_NAMESPACE", "knowledge"),
        SurrealDBDatabase:  getEnv("SURREALDB_DATABASE", "graph"),
        SurrealDBUser:      getEnv("SURREALDB_USER", "root"),
        SurrealDBPass:      getEnv("SURREALDB_PASS", "root"),
        SurrealDBAuthLevel: getEnv("SURREALDB_AUTH_LEVEL", "root"),

        // Ollama
        OllamaHost:     getEnv("OLLAMA_HOST", "http://localhost:11434"),
        EmbeddingModel: getEnv("MEMCP_EMBEDDING_MODEL", "all-minilm:l6-v2"),

        // Logging
        LogFile:  getEnv("MEMCP_LOG_FILE", "/tmp/memcp.log"),
        LogLevel: parseLogLevel(getEnv("MEMCP_LOG_LEVEL", "INFO")),

        // Context
        DefaultContext: getEnv("MEMCP_DEFAULT_CONTEXT", ""),
        ContextFromCWD: getEnv("MEMCP_CONTEXT_FROM_CWD", "false") == "true",
    }
}

func getEnv(key, defaultVal string) string {
    if val := os.Getenv(key); val != "" {
        return val
    }
    return defaultVal
}

func parseLogLevel(s string) slog.Level {
    switch strings.ToUpper(s) {
    case "DEBUG":
        return slog.LevelDebug
    case "INFO":
        return slog.LevelInfo
    case "WARN", "WARNING":
        return slog.LevelWarn
    case "ERROR":
        return slog.LevelError
    default:
        return slog.LevelInfo
    }
}
```

**internal/config/logging.go:**
```go
package config

import (
    "io"
    "log/slog"
    "os"

    slogmulti "github.com/samber/slog-multi"
)

// SetupLogger creates a dual-output logger: text to stderr, JSON to file.
// Returns the logger and a cleanup function to close the file.
func SetupLogger(logFile string, level slog.Level) (*slog.Logger, func() error) {
    // Stderr handler (text for readability)
    stderrHandler := slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
        Level: level,
    })

    // Try to open log file
    file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        // Fall back to stderr-only if file fails
        slog.Error("failed to open log file, using stderr only", "error", err, "file", logFile)
        return slog.New(stderrHandler), func() error { return nil }
    }

    // File handler (JSON for machine parsing)
    fileHandler := slog.NewJSONHandler(file, &slog.HandlerOptions{
        Level: level,
    })

    // Fanout to both handlers
    logger := slog.New(slogmulti.Fanout(stderrHandler, fileHandler))

    cleanup := func() error {
        return file.Close()
    }

    return logger, cleanup
}

// SetupLoggerWithWriters creates a logger with custom writers (for testing).
func SetupLoggerWithWriters(stderr, file io.Writer, level slog.Level) *slog.Logger {
    stderrHandler := slog.NewTextHandler(stderr, &slog.HandlerOptions{Level: level})
    fileHandler := slog.NewJSONHandler(file, &slog.HandlerOptions{Level: level})
    return slog.New(slogmulti.Fanout(stderrHandler, fileHandler))
}
```
  </action>
  <verify>
`go build ./internal/config/...` compiles without errors
  </verify>
  <done>Config loads all env vars with Python-matching defaults, logger outputs to both stderr (text) and file (JSON)</done>
</task>

</tasks>

<verification>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go

# Full build verification
go build ./...

# Verify models compile and have correct structure
go build ./internal/models/...

# Verify config compiles
go build ./internal/config/...

# Run go vet for static analysis
go vet ./...

# Test that module is properly initialized
go mod verify
```
</verification>

<success_criteria>
1. `go build ./...` completes without errors
2. `go.mod` contains all required dependencies (modelcontextprotocol/go-sdk, surrealdb.go, ollama/api, slog-multi)
3. Model structs in `internal/models/` have JSON tags matching Python field names (snake_case)
4. `internal/config/config.go` has Load() function with Python-matching defaults
5. `internal/config/logging.go` creates dual-output logger (stderr text + file JSON)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
