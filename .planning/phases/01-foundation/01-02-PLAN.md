---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/db/client.go
  - internal/db/schema.go
  - internal/db/client_test.go
autonomous: true

must_haves:
  truths:
    - "SurrealDB connection authenticates successfully"
    - "Connection persists across simulated reconnection events"
    - "Schema initializes without errors"
    - "Integration test passes with running SurrealDB instance"
  artifacts:
    - path: "internal/db/client.go"
      provides: "SurrealDB client with rews auto-reconnect"
      contains: "type Client struct"
      exports: ["NewClient", "Close", "DB", "InitSchema"]
    - path: "internal/db/schema.go"
      provides: "Schema SQL constant matching Python"
      contains: "const SchemaSQL"
    - path: "internal/db/client_test.go"
      provides: "Integration tests for SurrealDB connection"
      contains: "func TestClient"
  key_links:
    - from: "internal/db/client.go"
      to: "surrealdb.go/contrib/rews"
      via: "rews.New() connection factory"
      pattern: "rews\\.New"
    - from: "internal/db/client.go"
      to: "internal/config"
      via: "Config struct parameter"
      pattern: "config\\.Config"
---

<objective>
Implement SurrealDB client with auto-reconnecting WebSocket connection using the rews package, including schema initialization and integration tests.

Purpose: Reliable database connectivity is critical - rews handles authentication restoration after network interruptions.
Output: Working SurrealDB client that maintains connection state across reconnects.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Python DB connection pattern
@memcp/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SurrealDB client with rews auto-reconnect</name>
  <files>internal/db/client.go</files>
  <action>
Create SurrealDB client using rews package for automatic reconnection with session restoration.

```go
// internal/db/client.go
package db

import (
    "context"
    "fmt"
    "log/slog"
    "time"

    "github.com/surrealdb/surrealdb.go"
    "github.com/surrealdb/surrealdb.go/contrib/rews"
    "github.com/surrealdb/surrealdb.go/pkg/connection"
    "github.com/surrealdb/surrealdb.go/pkg/connection/gws"
    "github.com/surrealdb/surrealdb.go/pkg/encoding/cbor"
)

// Config holds SurrealDB connection configuration.
type Config struct {
    URL        string
    Namespace  string
    Database   string
    Username   string
    Password   string
    AuthLevel  string // "root" or "database"
}

// Client wraps SurrealDB connection with auto-reconnect.
type Client struct {
    conn   *rews.Connection
    db     *surrealdb.DB
    cfg    Config
    logger *slog.Logger
}

// NewClient creates a new SurrealDB client with auto-reconnecting WebSocket.
func NewClient(ctx context.Context, cfg Config, logger *slog.Logger) (*Client, error) {
    if logger == nil {
        logger = slog.Default()
    }

    marshaler := cbor.NewMarshaler()
    unmarshaler := cbor.NewUnmarshaler()

    // Create rews connection with auto-reconnect
    conn := rews.New(
        func(ctx context.Context) (connection.WebSocketConnection, error) {
            ws := gws.New(&connection.Config{
                BaseURL:     cfg.URL,
                Marshaler:   marshaler,
                Unmarshaler: unmarshaler,
            })
            return ws, nil
        },
        5*time.Second,
        unmarshaler,
        logger,
    )

    // Configure exponential backoff
    retryer := rews.NewExponentialBackoffRetryer()
    retryer.InitialDelay = 1 * time.Second
    retryer.MaxDelay = 30 * time.Second
    retryer.Multiplier = 2.0
    retryer.MaxRetries = 10
    conn.Retryer = retryer

    // Connect
    logger.Info("connecting to SurrealDB", "url", cfg.URL)
    if err := conn.Connect(ctx); err != nil {
        return nil, fmt.Errorf("connect: %w", err)
    }

    // Create DB wrapper
    db, err := surrealdb.FromConnection(ctx, conn)
    if err != nil {
        conn.Close(ctx)
        return nil, fmt.Errorf("from connection: %w", err)
    }

    // Authenticate based on auth level
    logger.Info("authenticating", "user", cfg.Username, "auth_level", cfg.AuthLevel)
    if cfg.AuthLevel == "database" {
        _, err = db.SignIn(ctx, surrealdb.Auth{
            Namespace: cfg.Namespace,
            Database:  cfg.Database,
            Username:  cfg.Username,
            Password:  cfg.Password,
        })
    } else {
        // Default to root auth
        _, err = db.SignIn(ctx, surrealdb.Auth{
            Username: cfg.Username,
            Password: cfg.Password,
        })
    }
    if err != nil {
        conn.Close(ctx)
        return nil, fmt.Errorf("signin: %w", err)
    }

    // Select namespace/database
    logger.Info("selecting namespace/database", "namespace", cfg.Namespace, "database", cfg.Database)
    if err := db.Use(ctx, cfg.Namespace, cfg.Database); err != nil {
        conn.Close(ctx)
        return nil, fmt.Errorf("use: %w", err)
    }

    logger.Info("SurrealDB connection established")
    return &Client{conn: conn, db: db, cfg: cfg, logger: logger}, nil
}

// Close closes the SurrealDB connection.
func (c *Client) Close(ctx context.Context) error {
    c.logger.Info("closing SurrealDB connection")
    return c.conn.Close(ctx)
}

// DB returns the underlying SurrealDB client for queries.
func (c *Client) DB() *surrealdb.DB {
    return c.db
}

// InitSchema initializes the database schema.
func (c *Client) InitSchema(ctx context.Context) error {
    c.logger.Info("initializing database schema")
    _, err := c.db.Query(ctx, SchemaSQL, nil)
    if err != nil {
        return fmt.Errorf("init schema: %w", err)
    }
    c.logger.Info("schema initialization complete")
    return nil
}

// Query executes a SurrealQL query with parameters.
func (c *Client) Query(ctx context.Context, sql string, vars map[string]interface{}) (interface{}, error) {
    return c.db.Query(ctx, sql, vars)
}
```

CRITICAL: Use `contrib/rews` (not direct WebSocket) - it handles auth/namespace restoration after reconnect. Configure exponential backoff with reasonable limits (10 retries, 30s max delay).
  </action>
  <verify>
`go build ./internal/db/...` compiles without errors
  </verify>
  <done>Client struct exists with NewClient, Close, DB, InitSchema, Query methods using rews for auto-reconnect</done>
</task>

<task type="auto">
  <name>Task 2: Create schema SQL constant</name>
  <files>internal/db/schema.go</files>
  <action>
Port the schema SQL from Python `memcp/db.py` SCHEMA_SQL constant exactly.

```go
// internal/db/schema.go
package db

// SchemaSQL contains the database schema initialization SQL.
// Matches Python memcp/db.py SCHEMA_SQL exactly.
const SchemaSQL = `
    -- ==========================================================================
    -- ENTITY TABLE
    -- ==========================================================================
    DEFINE TABLE IF NOT EXISTS entity SCHEMAFULL;
    DEFINE FIELD IF NOT EXISTS type ON entity TYPE string;
    DEFINE FIELD IF NOT EXISTS labels ON entity TYPE array<string>;
    DEFINE FIELD IF NOT EXISTS content ON entity TYPE string;
    DEFINE FIELD IF NOT EXISTS embedding ON entity TYPE array<float>;
    DEFINE FIELD IF NOT EXISTS confidence ON entity TYPE float DEFAULT 1.0;
    DEFINE FIELD IF NOT EXISTS source ON entity TYPE option<string>;
    DEFINE FIELD IF NOT EXISTS decay_weight ON entity TYPE float DEFAULT 1.0;
    DEFINE FIELD IF NOT EXISTS created ON entity TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS accessed ON entity TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS access_count ON entity TYPE int DEFAULT 0;
    DEFINE FIELD IF NOT EXISTS context ON entity TYPE option<string>;
    DEFINE FIELD IF NOT EXISTS importance ON entity TYPE float DEFAULT 0.5;
    DEFINE FIELD IF NOT EXISTS user_importance ON entity TYPE option<float>;

    DEFINE INDEX IF NOT EXISTS entity_labels ON entity FIELDS labels;
    DEFINE INDEX IF NOT EXISTS entity_context ON entity FIELDS context;
    DEFINE INDEX IF NOT EXISTS entity_embedding ON entity FIELDS embedding HNSW DIMENSION 384 DIST COSINE TYPE F32;
    DEFINE ANALYZER IF NOT EXISTS entity_analyzer TOKENIZERS class FILTERS lowercase, ascii, snowball(english);
    DEFINE INDEX IF NOT EXISTS entity_content_ft ON entity FIELDS content FULLTEXT ANALYZER entity_analyzer BM25;

    -- ==========================================================================
    -- RELATIONS TABLE
    -- ==========================================================================
    DEFINE TABLE IF NOT EXISTS relates TYPE RELATION IN entity OUT entity SCHEMAFULL;
    DEFINE FIELD IF NOT EXISTS rel_type ON relates TYPE string;
    DEFINE FIELD IF NOT EXISTS weight ON relates TYPE float DEFAULT 1.0;
    DEFINE FIELD IF NOT EXISTS created ON relates TYPE datetime DEFAULT time::now();
    DEFINE FIELD unique_key ON relates VALUE <string>string::concat(array::sort([<string>in, <string>out]), rel_type);
    DEFINE INDEX IF NOT EXISTS unique_relation ON relates FIELDS unique_key UNIQUE;

    -- ==========================================================================
    -- EPISODE TABLE (Episodic Memory)
    -- ==========================================================================
    DEFINE TABLE IF NOT EXISTS episode SCHEMAFULL;
    DEFINE FIELD IF NOT EXISTS content ON episode TYPE string;
    DEFINE FIELD IF NOT EXISTS summary ON episode TYPE option<string>;
    DEFINE FIELD IF NOT EXISTS embedding ON episode TYPE array<float>;
    DEFINE FIELD IF NOT EXISTS metadata ON episode TYPE option<object> FLEXIBLE;
    DEFINE FIELD IF NOT EXISTS timestamp ON episode TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS context ON episode TYPE option<string>;
    DEFINE FIELD IF NOT EXISTS created ON episode TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS accessed ON episode TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS access_count ON episode TYPE int DEFAULT 0;

    DEFINE INDEX IF NOT EXISTS episode_timestamp ON episode FIELDS timestamp;
    DEFINE INDEX IF NOT EXISTS episode_context ON episode FIELDS context;
    DEFINE INDEX IF NOT EXISTS episode_embedding ON episode FIELDS embedding HNSW DIMENSION 384 DIST COSINE TYPE F32;
    DEFINE ANALYZER IF NOT EXISTS episode_analyzer TOKENIZERS class FILTERS lowercase, ascii, snowball(english);
    DEFINE INDEX IF NOT EXISTS episode_content_ft ON episode FIELDS content FULLTEXT ANALYZER episode_analyzer BM25;

    -- ==========================================================================
    -- EXTRACTED_FROM RELATION (links entities to source episodes)
    -- ==========================================================================
    DEFINE TABLE IF NOT EXISTS extracted_from TYPE RELATION IN entity OUT episode SCHEMAFULL;
    DEFINE FIELD IF NOT EXISTS position ON extracted_from TYPE option<int>;
    DEFINE FIELD IF NOT EXISTS confidence ON extracted_from TYPE float DEFAULT 1.0;
    DEFINE FIELD IF NOT EXISTS created ON extracted_from TYPE datetime DEFAULT time::now();

    -- ==========================================================================
    -- PROCEDURE TABLE (Procedural Memory)
    -- ==========================================================================
    DEFINE TABLE IF NOT EXISTS procedure SCHEMAFULL;
    DEFINE FIELD IF NOT EXISTS name ON procedure TYPE string;
    DEFINE FIELD IF NOT EXISTS description ON procedure TYPE string;
    DEFINE FIELD IF NOT EXISTS steps ON procedure TYPE array<object> FLEXIBLE;
    REMOVE FIELD IF EXISTS steps.* ON procedure;
    DEFINE FIELD steps.* ON procedure TYPE object FLEXIBLE;
    DEFINE FIELD IF NOT EXISTS embedding ON procedure TYPE array<float>;
    DEFINE FIELD IF NOT EXISTS context ON procedure TYPE option<string>;
    DEFINE FIELD IF NOT EXISTS labels ON procedure TYPE array<string>;
    DEFINE FIELD IF NOT EXISTS created ON procedure TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS accessed ON procedure TYPE datetime DEFAULT time::now();
    DEFINE FIELD IF NOT EXISTS access_count ON procedure TYPE int DEFAULT 0;

    DEFINE INDEX IF NOT EXISTS procedure_context ON procedure FIELDS context;
    DEFINE INDEX IF NOT EXISTS procedure_labels ON procedure FIELDS labels;
    DEFINE INDEX IF NOT EXISTS procedure_embedding ON procedure FIELDS embedding HNSW DIMENSION 384 DIST COSINE TYPE F32;
    DEFINE ANALYZER IF NOT EXISTS procedure_analyzer TOKENIZERS class FILTERS lowercase, ascii, snowball(english);
    DEFINE INDEX IF NOT EXISTS procedure_name_ft ON procedure FIELDS name FULLTEXT ANALYZER procedure_analyzer BM25;
    DEFINE INDEX IF NOT EXISTS procedure_desc_ft ON procedure FIELDS description FULLTEXT ANALYZER procedure_analyzer BM25;

    -- ==========================================================================
    -- TYPE INDEX (for entity type ontology queries)
    -- ==========================================================================
    DEFINE INDEX IF NOT EXISTS entity_type ON entity FIELDS type;
`
```

CRITICAL: HNSW indices MUST use DIMENSION 384 to match all-minilm:l6-v2 embeddings.
  </action>
  <verify>
`go build ./internal/db/...` compiles without errors
  </verify>
  <done>SchemaSQL constant matches Python schema exactly with DIMENSION 384 HNSW indices</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests</name>
  <files>internal/db/client_test.go</files>
  <action>
Create integration tests that verify connection, authentication, and schema initialization.
Tests require a running SurrealDB instance.

```go
// internal/db/client_test.go
package db_test

import (
    "context"
    "log/slog"
    "os"
    "testing"
    "time"

    "github.com/raphaelgruber/memcp-go/internal/db"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// getTestConfig returns config from environment or defaults for local testing.
func getTestConfig() db.Config {
    return db.Config{
        URL:       getEnv("SURREALDB_URL", "ws://localhost:8000/rpc"),
        Namespace: getEnv("SURREALDB_NAMESPACE", "test_knowledge"),
        Database:  getEnv("SURREALDB_DATABASE", "test_graph"),
        Username:  getEnv("SURREALDB_USER", "root"),
        Password:  getEnv("SURREALDB_PASS", "root"),
        AuthLevel: getEnv("SURREALDB_AUTH_LEVEL", "root"),
    }
}

func getEnv(key, defaultVal string) string {
    if val := os.Getenv(key); val != "" {
        return val
    }
    return defaultVal
}

func TestClientConnect(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    cfg := getTestConfig()
    logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))

    client, err := db.NewClient(ctx, cfg, logger)
    require.NoError(t, err, "should connect to SurrealDB")
    defer client.Close(ctx)

    assert.NotNil(t, client.DB(), "should have valid DB reference")
}

func TestClientInitSchema(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    cfg := getTestConfig()
    logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))

    client, err := db.NewClient(ctx, cfg, logger)
    require.NoError(t, err, "should connect to SurrealDB")
    defer client.Close(ctx)

    err = client.InitSchema(ctx)
    require.NoError(t, err, "should initialize schema without error")

    // Verify tables exist by querying INFO FOR DB
    result, err := client.Query(ctx, "INFO FOR DB", nil)
    require.NoError(t, err, "should query database info")
    assert.NotNil(t, result, "should return database info")
}

func TestClientQuery(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    cfg := getTestConfig()
    logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))

    client, err := db.NewClient(ctx, cfg, logger)
    require.NoError(t, err, "should connect to SurrealDB")
    defer client.Close(ctx)

    err = client.InitSchema(ctx)
    require.NoError(t, err, "should initialize schema")

    // Test simple query
    result, err := client.Query(ctx, "SELECT count() FROM entity GROUP ALL", nil)
    require.NoError(t, err, "should execute count query")
    assert.NotNil(t, result, "should return result")
}

func TestClientReconnection(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
    defer cancel()

    cfg := getTestConfig()
    logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))

    client, err := db.NewClient(ctx, cfg, logger)
    require.NoError(t, err, "should connect to SurrealDB")
    defer client.Close(ctx)

    // Execute query before and after a short wait to verify connection stays alive
    _, err = client.Query(ctx, "RETURN 1", nil)
    require.NoError(t, err, "should execute query before wait")

    time.Sleep(2 * time.Second)

    _, err = client.Query(ctx, "RETURN 2", nil)
    require.NoError(t, err, "should execute query after wait (connection maintained)")
}
```

Note: Tests use `test_knowledge`/`test_graph` namespace/database to avoid polluting production data.
  </action>
  <verify>
`go build ./internal/db/...` compiles without errors
`go test ./internal/db/... -short` (skip integration tests)
With SurrealDB running: `go test ./internal/db/... -v`
  </verify>
  <done>Integration tests exist for connect, schema init, query, and reconnection verification</done>
</task>

</tasks>

<verification>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go

# Build verification
go build ./internal/db/...

# Static analysis
go vet ./internal/db/...

# Unit tests (no SurrealDB needed)
go test ./internal/db/... -short

# Integration tests (requires SurrealDB running)
# Start SurrealDB first: docker run -p 8000:8000 surrealdb/surrealdb:latest start --user root --pass root
go test ./internal/db/... -v
```
</verification>

<success_criteria>
1. `internal/db/client.go` exists with NewClient, Close, DB, InitSchema, Query methods
2. NewClient uses rews.New() for auto-reconnecting WebSocket
3. Authentication supports both root and database auth levels
4. `internal/db/schema.go` contains SchemaSQL matching Python exactly (DIMENSION 384)
5. Integration tests pass with running SurrealDB instance
6. Connection persists across short wait periods (rews keepalive working)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
