---
phase: 07-procedure-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/queries.go
  - internal/tools/procedure.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can create procedures with name, description, and ordered steps"
    - "User can retrieve procedure by ID with full steps"
    - "User can delete procedure by ID"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "Procedure query functions"
      contains: "QueryCreateProcedure"
    - path: "internal/tools/procedure.go"
      provides: "Procedure tool handlers"
      exports: ["NewCreateProcedureHandler", "NewGetProcedureHandler", "NewDeleteProcedureHandler"]
    - path: "internal/tools/registry.go"
      provides: "Tool registration"
      contains: "create_procedure"
  key_links:
    - from: "internal/tools/procedure.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryCreateProcedure"
      pattern: "deps\\.DB\\.QueryCreateProcedure"
    - from: "internal/tools/registry.go"
      to: "internal/tools/procedure.go"
      via: "NewCreateProcedureHandler registration"
      pattern: "NewCreateProcedureHandler"
---

<objective>
Implement procedure CRUD tools: create_procedure, get_procedure, delete_procedure.

Purpose: Enable agents to store procedural memories (step-by-step workflows/processes) and retrieve/delete them by ID.
Output: Three working MCP tools for procedure management.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-procedure-tools/07-CONTEXT.md
@.planning/phases/07-procedure-tools/07-RESEARCH.md
@internal/models/procedure.go
@internal/db/queries.go
@internal/tools/episode.go
@internal/tools/registry.go
@internal/tools/helpers.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add procedure query functions to db/queries.go</name>
  <files>internal/db/queries.go</files>
  <action>
Add the following query functions to db/queries.go:

1. **QueryCreateProcedure** - Create/upsert procedure:
   - Params: ctx, procedureID, name, description string, steps []models.ProcedureStep, embedding []float32, labels []string, procedureContext *string
   - Use `UPSERT type::record("procedure", $id)` pattern (same as entity/episode)
   - Set all fields: name, description, steps, embedding, labels, context
   - Set created=time::now() on insert, preserve on update (use IF created THEN created ELSE time::now() END)
   - Set accessed=time::now(), access_count defaults
   - Return *models.Procedure, error

2. **QueryGetProcedure** - Retrieve procedure by ID:
   - Params: ctx, id string
   - Use `SELECT * FROM type::record("procedure", $id)`
   - Return *models.Procedure, error (nil if not found)

3. **QueryUpdateProcedureAccess** - Update access tracking:
   - Params: ctx, id string
   - Update accessed=time::now(), access_count+=1
   - Return error (fire-and-forget pattern)

4. **QueryDeleteProcedure** - Delete procedure by ID:
   - Params: ctx, id string
   - Use `DELETE type::record("procedure", $id) RETURN BEFORE`
   - Return count int, error (0 if not found, idempotent)

Follow existing patterns from QueryCreateEpisode and QueryDeleteEpisode:
- Use surrealdb.Query[T] generic pattern
- Handle nil/empty results consistently
- Wrap errors with fmt.Errorf
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: New functions exist with correct signatures
  </verify>
  <done>
4 query functions added: QueryCreateProcedure, QueryGetProcedure, QueryUpdateProcedureAccess, QueryDeleteProcedure
  </done>
</task>

<task type="auto">
  <name>Task 2: Create procedure.go with CRUD tool handlers</name>
  <files>internal/tools/procedure.go</files>
  <action>
Create internal/tools/procedure.go with three tool handlers:

**Input types:**

```go
// ProcedureStepInput represents a step in the input.
type ProcedureStepInput struct {
    Content  string `json:"content" jsonschema:"required,Step instruction/description"`
    Optional bool   `json:"optional,omitempty" jsonschema:"Whether step can be skipped"`
}

type CreateProcedureInput struct {
    Name        string               `json:"name" jsonschema:"required,Unique procedure name"`
    Description string               `json:"description" jsonschema:"required,What this procedure accomplishes"`
    Steps       []ProcedureStepInput `json:"steps" jsonschema:"required,Ordered list of steps (minimum 1)"`
    Labels      []string             `json:"labels,omitempty" jsonschema:"Tags for categorization"`
    Context     string               `json:"context,omitempty" jsonschema:"Project namespace (auto-detected if omitted)"`
}

type GetProcedureInput struct {
    ID string `json:"id" jsonschema:"required,Procedure ID (with or without 'procedure:' prefix)"`
}

type DeleteProcedureInput struct {
    ID string `json:"id" jsonschema:"required,Procedure ID to delete"`
}
```

**Result types:**

```go
type CreateProcedureResult struct {
    ID          string   `json:"id"`
    Name        string   `json:"name"`
    Description string   `json:"description"`
    StepCount   int      `json:"step_count"`
    Labels      []string `json:"labels,omitempty"`
    Context     *string  `json:"context,omitempty"`
    Action      string   `json:"action"` // "created" or "updated"
}

type GetProcedureResult struct {
    Procedure *models.Procedure `json:"procedure"`
}

type DeleteProcedureResult struct {
    Deleted int    `json:"deleted"`
    Message string `json:"message"`
}
```

**Handlers:**

1. **NewCreateProcedureHandler(deps, cfg):**
   - Validate name, description not empty
   - Validate steps has at least 1 element
   - Validate each step has content
   - Generate ID using slugify(name) + optional context prefix (reuse slugify from remember.go)
   - Convert []ProcedureStepInput to []models.ProcedureStep with order index
   - Detect context using DetectContext(cfg)
   - Generate embedding from combined text: name + " " + description + " " + steps content joined
   - Check if procedure exists (to set action = "created" or "updated")
   - Call QueryCreateProcedure
   - Return JSON with ID, name, step_count, action

2. **NewGetProcedureHandler(deps):**
   - Extract bare ID (strip "procedure:" prefix)
   - Call QueryGetProcedure
   - Return ErrorResult if not found
   - Call QueryUpdateProcedureAccess
   - Return full procedure with all steps

3. **NewDeleteProcedureHandler(deps):**
   - Extract bare ID
   - Call QueryDeleteProcedure
   - Return count of deleted (0 if not found, idempotent)

**Helper functions:**
- `extractProcedureID(id string) string` - strips "procedure:" prefix
- Reuse `slugify` from remember.go (it's already exported via lowercase)
- Reuse `truncateContent` from episode.go if needed for logging

Follow existing patterns from episode.go:
- Use ErrorResult for validation/not-found errors
- Use TextResult for JSON output
- Log operations via deps.Logger
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: procedure.go exports NewCreateProcedureHandler, NewGetProcedureHandler, NewDeleteProcedureHandler
  </verify>
  <done>
procedure.go created with 3 handlers, input/result types, and helper functions
  </done>
</task>

<task type="auto">
  <name>Task 3: Register procedure CRUD tools in registry.go</name>
  <files>internal/tools/registry.go</files>
  <action>
Update RegisterAll() in registry.go to register the three procedure tools:

```go
// Create procedure tool - store procedural memories
mcp.AddTool(server, &mcp.Tool{
    Name:        "create_procedure",
    Description: "Store a step-by-step procedure (workflow, process, how-to) with ordered steps and auto-generated embedding",
}, NewCreateProcedureHandler(deps, cfg))

// Get procedure tool - retrieve by ID
mcp.AddTool(server, &mcp.Tool{
    Name:        "get_procedure",
    Description: "Retrieve a procedural memory by its ID with all steps",
}, NewGetProcedureHandler(deps))

// Delete procedure tool - remove by ID
mcp.AddTool(server, &mcp.Tool{
    Name:        "delete_procedure",
    Description: "Delete a procedural memory by its ID",
}, NewDeleteProcedureHandler(deps))
```

Place after existing episode tools (search_episodes).
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Run: Check via MCP inspector - should list 16 tools total
  </verify>
  <done>
3 procedure tools registered: create_procedure, get_procedure, delete_procedure
Total tools: 16 (13 existing + 3 new)
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./...` passes (existing tests)
3. Manual verification: Start server, use MCP inspector to:
   - Call create_procedure with name "Git Workflow", description, steps - returns procedure ID
   - Call get_procedure with returned ID - shows full procedure with all steps
   - Call delete_procedure with ID - returns deleted count 1
   - Call get_procedure again - returns not found
</verification>

<success_criteria>
- [ ] QueryCreateProcedure, QueryGetProcedure, QueryUpdateProcedureAccess, QueryDeleteProcedure in db/queries.go
- [ ] procedure.go with 3 handlers + input/result types
- [ ] 3 tools registered in registry.go
- [ ] `go build ./...` passes
- [ ] create_procedure stores procedure with steps and embedding
- [ ] get_procedure retrieves by ID with full steps
- [ ] delete_procedure removes procedure
</success_criteria>

<output>
After completion, create `.planning/phases/07-procedure-tools/07-01-SUMMARY.md`
</output>
