---
phase: 07-procedure-tools
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - internal/db/queries.go
  - internal/tools/procedure.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can search procedures by semantic content"
    - "User can filter procedures by labels"
    - "User can filter procedures by context"
    - "User can list all procedures with optional context filter"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "Procedure search and list queries"
      contains: "QuerySearchProcedures"
    - path: "internal/tools/procedure.go"
      provides: "Search and list handlers"
      exports: ["NewSearchProceduresHandler", "NewListProceduresHandler"]
    - path: "internal/tools/registry.go"
      provides: "Tool registration"
      contains: "search_procedures"
  key_links:
    - from: "internal/tools/procedure.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QuerySearchProcedures"
      pattern: "deps\\.DB\\.QuerySearchProcedures"
    - from: "internal/tools/registry.go"
      to: "internal/tools/procedure.go"
      via: "NewSearchProceduresHandler registration"
      pattern: "NewSearchProceduresHandler"
---

<objective>
Implement search_procedures and list_procedures tools with hybrid search and filtering.

Purpose: Enable agents to find relevant procedural memories by semantic content and list all procedures.
Output: Two working MCP tools for procedure discovery.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-procedure-tools/07-CONTEXT.md
@.planning/phases/07-procedure-tools/07-RESEARCH.md
@.planning/phases/07-procedure-tools/07-01-SUMMARY.md
@internal/models/procedure.go
@internal/db/queries.go
@internal/tools/procedure.go
@internal/tools/search.go
@internal/tools/registry.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QuerySearchProcedures and QueryListProcedures to db/queries.go</name>
  <files>internal/db/queries.go</files>
  <action>
Add the following query functions to db/queries.go:

1. **QuerySearchProcedures** - Hybrid BM25+vector search:

```go
// QuerySearchProcedures performs hybrid BM25+vector search on procedures.
// Searches name and description fields. Supports label and context filtering.
// Returns procedures ranked by RRF fusion.
func (c *Client) QuerySearchProcedures(
    ctx context.Context,
    query string,
    embedding []float32,
    labels []string,
    contextFilter *string,
    limit int,
) ([]models.Procedure, error)
```

**Implementation details:**

Build dynamic filter clauses:
- If len(labels) > 0: ` AND labels CONTAINSANY $labels`
- If contextFilter != nil: ` AND context = $context`

Use search::rrf() for hybrid search (same pattern as entity search):
- Vector subquery: `embedding <|{limit*2},40|> $emb` with filters
- BM25 subquery: `name @0@ $q OR description @1@ $q` with filters
  - Note: procedure_name_ft is index 0, procedure_desc_ft is index 1
- RRF k=60

SQL template:
```sql
SELECT * FROM search::rrf([
    (SELECT id, name, description, steps, labels, context, accessed, access_count
     FROM procedure
     WHERE embedding <|%d,40|> $emb %s %s),
    (SELECT id, name, description, steps, labels, context, accessed, access_count
     FROM procedure
     WHERE name @0@ $q OR description @1@ $q %s %s)
], $limit, 60)
```

Variables map:
- q: query string
- emb: embedding vector
- labels: optional array
- context: optional string
- limit: int

Return []models.Procedure (empty slice if no results)

2. **QueryListProcedures** - List all procedures with optional context filter:

```go
// QueryListProcedures returns all procedures with optional context filtering.
// Returns procedures ordered by last access time (most recent first).
func (c *Client) QueryListProcedures(
    ctx context.Context,
    contextFilter *string,
    limit int,
) ([]models.Procedure, error)
```

**Implementation:**
- If contextFilter != nil: `WHERE context = $context`
- ORDER BY accessed DESC
- LIMIT $limit

Return []models.Procedure with id, name, description, labels, context, step count (via array::len(steps)), accessed

Follow existing QueryHybridSearch pattern for structure.
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: QuerySearchProcedures and QueryListProcedures exist with correct signatures
  </verify>
  <done>
2 query functions added: QuerySearchProcedures, QueryListProcedures
  </done>
</task>

<task type="auto">
  <name>Task 2: Add search_procedures and list_procedures handlers to procedure.go</name>
  <files>internal/tools/procedure.go</files>
  <action>
Add to internal/tools/procedure.go:

**Input types:**

```go
type SearchProceduresInput struct {
    Query   string   `json:"query" jsonschema:"required,Semantic search query"`
    Labels  []string `json:"labels,omitempty" jsonschema:"Filter by labels (matches ANY)"`
    Context string   `json:"context,omitempty" jsonschema:"Project namespace filter (auto-detected if omitted)"`
    Limit   int      `json:"limit,omitempty" jsonschema:"Max results 1-50 (default 10)"`
}

type ListProceduresInput struct {
    Context string `json:"context,omitempty" jsonschema:"Project namespace filter (auto-detected if omitted)"`
    Limit   int    `json:"limit,omitempty" jsonschema:"Max results 1-100 (default 50)"`
}
```

**Result types:**

```go
type ProcedureSearchResult struct {
    Procedures []ProcedureSummary `json:"procedures"`
    Count      int                `json:"count"`
}

// ProcedureSummary is a lightweight procedure representation for search/list results.
type ProcedureSummary struct {
    ID          string   `json:"id"`
    Name        string   `json:"name"`
    Description string   `json:"description"`
    StepCount   int      `json:"step_count"`
    Labels      []string `json:"labels,omitempty"`
    Context     *string  `json:"context,omitempty"`
}
```

**Handlers:**

1. **NewSearchProceduresHandler(deps, cfg):**
   - Validate query not empty
   - Set limit defaults (10) and validate (1-50)
   - Generate embedding via deps.Embedder.Embed()
   - Detect context: explicit > DetectContext(cfg)
   - Call deps.DB.QuerySearchProcedures()
   - Update access tracking for each result (fire-and-forget goroutines)
   - Build response with ProcedureSummary (id, name, description, step_count, labels, context)
   - Log query (truncated) and result count

2. **NewListProceduresHandler(deps, cfg):**
   - Set limit defaults (50) and validate (1-100)
   - Detect context: explicit > DetectContext(cfg)
   - Call deps.DB.QueryListProcedures()
   - Build response with ProcedureSummary list
   - Log result count

**Notes:**
- Search and list return summaries (no full steps array) for efficiency
- Use get_procedure to retrieve full steps
- Follow same fire-and-forget access tracking pattern from episode search
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: NewSearchProceduresHandler and NewListProceduresHandler exist and exported
  </verify>
  <done>
2 handlers added: NewSearchProceduresHandler, NewListProceduresHandler with input/result types
  </done>
</task>

<task type="auto">
  <name>Task 3: Register search_procedures and list_procedures in registry.go</name>
  <files>internal/tools/registry.go</files>
  <action>
Add to RegisterAll() in registry.go after the procedure CRUD tools:

```go
// Search procedures tool - semantic search with filtering
mcp.AddTool(server, &mcp.Tool{
    Name:        "search_procedures",
    Description: "Search procedural memories by semantic content. Use to find relevant workflows, processes, or how-to guides.",
}, NewSearchProceduresHandler(deps, cfg))

// List procedures tool - enumerate all procedures
mcp.AddTool(server, &mcp.Tool{
    Name:        "list_procedures",
    Description: "List all stored procedures with optional context filtering. Returns summaries, use get_procedure for full steps.",
}, NewListProceduresHandler(deps, cfg))
```

Place after delete_procedure.
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Run: Check via MCP inspector - should list 18 tools total
  </verify>
  <done>
2 tools registered: search_procedures, list_procedures
Total tools: 18 (16 from plan 01 + 2 new)
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./...` passes (existing tests)
3. Manual verification: Start server, use MCP inspector to:
   - Create some test procedures with create_procedure
   - Call search_procedures with query "git" - returns matching procedures
   - Call search_procedures with labels filter - filters by labels
   - Call list_procedures - returns all procedures
   - Call list_procedures with context filter - filters by context
</verification>

<success_criteria>
- [ ] QuerySearchProcedures with hybrid BM25+vector search in db/queries.go
- [ ] QueryListProcedures with context filtering in db/queries.go
- [ ] SearchProceduresInput, ListProceduresInput types in procedure.go
- [ ] NewSearchProceduresHandler and NewListProceduresHandler in procedure.go
- [ ] 2 tools registered in registry.go
- [ ] `go build ./...` passes
- [ ] Semantic search finds relevant procedures
- [ ] Label filtering works
- [ ] Context filtering works
- [ ] List returns all procedures ordered by access time
</success_criteria>

<output>
After completion, create `.planning/phases/07-procedure-tools/07-02-SUMMARY.md`
</output>
