---
phase: 05-graph-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/queries.go
  - internal/tools/traverse.go
  - internal/tools/traverse_test.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can explore neighbors up to specified depth"
    - "Traversal respects relation_types filter when provided"
    - "Results include connected entities at each depth level"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "QueryTraverse function"
      contains: "func.*QueryTraverse"
    - path: "internal/tools/traverse.go"
      provides: "traverse tool handler"
      contains: "NewTraverseHandler"
    - path: "internal/tools/traverse_test.go"
      provides: "traverse tool tests"
      contains: "TestTraverse"
    - path: "internal/tools/registry.go"
      provides: "traverse registration"
      contains: "traverse"
  key_links:
    - from: "internal/tools/traverse.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryTraverse"
      pattern: "deps\\.DB\\.QueryTraverse"
    - from: "internal/tools/registry.go"
      to: "internal/tools/traverse.go"
      via: "NewTraverseHandler"
      pattern: "NewTraverseHandler"
---

<objective>
Implement the traverse MCP tool for exploring entity neighbors up to a specified depth.

Purpose: Enable agents to explore the knowledge graph structure by navigating from a starting entity to connected entities through relationships. This is essential for understanding context and discovering related knowledge.

Output: QueryTraverse database function, traverse tool handler, unit tests, registered in MCP server
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-graph-tools/05-RESEARCH.md
@internal/db/queries.go
@internal/tools/forget.go
@internal/tools/registry.go
@internal/tools/errors.go
@internal/tools/deps.go
@memcp/db.py (lines 526-541 for Python query_traverse pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueryTraverse to query layer</name>
  <files>internal/db/queries.go</files>
  <action>
Add QueryTraverse function to db/queries.go that performs bidirectional graph traversal.

**Function signature:**
```go
func (c *Client) QueryTraverse(
    ctx context.Context,
    startID string,
    depth int,
    relationTypes []string,
) ([]TraverseResult, error)
```

**TraverseResult type (add above QueryTraverse):**
```go
// TraverseResult contains an entity with its connected neighbors.
type TraverseResult struct {
    ID         string          `json:"id"`
    Type       string          `json:"type"`
    Labels     []string        `json:"labels"`
    Content    string          `json:"content"`
    Confidence float64         `json:"confidence"`
    Context    string          `json:"context"`
    Connected  []models.Entity `json:"connected"`
}
```

**SQL pattern (from Python):**
- Without filter: `SELECT *, ->relates..{depth}->entity AS connected FROM type::record("entity", $id)`
- With filter: `SELECT *, ->(SELECT * FROM relates WHERE rel_type IN $types)..{depth}->entity AS connected FROM type::record("entity", $id)`

**Implementation notes:**
- Build type filter clause dynamically based on relationTypes length
- Use fmt.Sprintf to inject depth into SQL (SurrealDB requires literal depth)
- Return empty slice if entity not found (consistent with existing patterns)
- Wrap error with "traverse: %w" format
  </action>
  <verify>
`go build ./...` compiles without errors
  </verify>
  <done>
QueryTraverse function exists in internal/db/queries.go with TraverseResult type
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement traverse tool handler with tests</name>
  <files>internal/tools/traverse.go, internal/tools/traverse_test.go, internal/tools/registry.go</files>
  <action>
**Create internal/tools/traverse.go:**

Follow the established handler factory pattern from forget.go.

```go
package tools

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/modelcontextprotocol/go-sdk/mcp"
)

// TraverseInput defines the input schema for the traverse tool.
type TraverseInput struct {
    Start         string   `json:"start" jsonschema:"required,Entity ID to start traversal from"`
    Depth         int      `json:"depth,omitempty" jsonschema:"Traversal depth 1-10 (default 2)"`
    RelationTypes []string `json:"relation_types,omitempty" jsonschema:"Filter by relation types"`
}

// NewTraverseHandler creates the traverse tool handler.
// Explores neighbors up to specified depth from starting entity.
func NewTraverseHandler(deps *Dependencies) mcp.ToolHandlerFor[TraverseInput, any] {
    return func(ctx context.Context, req *mcp.CallToolRequest, input TraverseInput) (
        *mcp.CallToolResult, any, error,
    ) {
        // Validate start
        if input.Start == "" {
            return ErrorResult("start cannot be empty", "Provide entity ID to start traversal"), nil, nil
        }

        // Set and validate depth
        depth := input.Depth
        if depth <= 0 {
            depth = 2
        }
        if depth > 10 {
            return ErrorResult("depth must be between 1 and 10", "Reduce depth value"), nil, nil
        }

        // Execute traversal
        results, err := deps.DB.QueryTraverse(ctx, input.Start, depth, input.RelationTypes)
        if err != nil {
            deps.Logger.Error("traverse failed", "start", input.Start, "error", err)
            return ErrorResult("Traversal failed", "Database may be unavailable"), nil, nil
        }

        // Handle empty result (entity not found)
        if len(results) == 0 {
            return ErrorResult(
                fmt.Sprintf("Entity not found: %s", input.Start),
                "Check entity ID exists",
            ), nil, nil
        }

        // Format response
        jsonBytes, _ := json.MarshalIndent(results[0], "", "  ")
        deps.Logger.Info("traverse completed", "start", input.Start, "depth", depth, "connected", len(results[0].Connected))
        return TextResult(string(jsonBytes)), nil, nil
    }
}
```

**Create internal/tools/traverse_test.go:**

```go
package tools

import (
    "testing"
)

func TestTraverseInput_Validation(t *testing.T) {
    tests := []struct {
        name    string
        input   TraverseInput
        wantErr bool
    }{
        {"empty start", TraverseInput{Start: ""}, true},
        {"valid start", TraverseInput{Start: "test:entity"}, false},
        {"with depth", TraverseInput{Start: "test:entity", Depth: 3}, false},
        {"with types", TraverseInput{Start: "test:entity", RelationTypes: []string{"related_to"}}, false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Input struct validation - empty start is error
            if tt.wantErr && tt.input.Start != "" {
                t.Errorf("expected error condition not met")
            }
            if !tt.wantErr && tt.input.Start == "" {
                t.Errorf("start should not be empty for valid case")
            }
        })
    }
}

func TestTraverseInput_DefaultDepth(t *testing.T) {
    input := TraverseInput{Start: "test:entity"}
    if input.Depth != 0 {
        t.Errorf("expected default depth 0 (will be set to 2), got %d", input.Depth)
    }
}

func TestTraverseInput_DepthBounds(t *testing.T) {
    // Depth validation happens in handler, struct allows any int
    input := TraverseInput{Start: "test:entity", Depth: 15}
    if input.Depth <= 10 {
        t.Errorf("expected depth > 10 for bounds test")
    }
}
```

**Update internal/tools/registry.go:**

Add traverse tool registration after forget:

```go
// Traverse tool - explore graph neighbors
mcp.AddTool(server, &mcp.Tool{
    Name:        "traverse",
    Description: "Explore how stored knowledge connects to other knowledge. Use when the user asks 'what's related to...', 'how does X connect to Y', or wants to understand context around a topic.",
}, NewTraverseHandler(deps))
```
  </action>
  <verify>
`go test ./internal/tools/... -v -run TestTraverse` passes
`go build ./...` compiles successfully
  </verify>
  <done>
- traverse.go exists with NewTraverseHandler
- traverse_test.go exists with validation tests
- traverse registered in registry.go
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./...

# Unit tests pass
go test ./internal/tools/... -v -run TestTraverse

# Full test suite still passes
go test ./...
```
</verification>

<success_criteria>
1. QueryTraverse function in db/queries.go handles depth and relation_types filter
2. traverse tool handler validates input (start required, depth 1-10)
3. Tool returns entity with connected neighbors as JSON
4. Tests verify input validation behavior
5. Tool registered and available in MCP server
</success_criteria>

<output>
After completion, create `.planning/phases/05-graph-tools/05-01-SUMMARY.md`
</output>
