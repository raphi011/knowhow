---
phase: 05-graph-tools
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/db/queries.go
  - internal/tools/find_path.go
  - internal/tools/find_path_test.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can find shortest path between two entities"
    - "Results indicate whether path was found"
    - "Path includes intermediate entities when found"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "QueryFindPath function"
      contains: "func.*QueryFindPath"
    - path: "internal/tools/find_path.go"
      provides: "find_path tool handler"
      contains: "NewFindPathHandler"
    - path: "internal/tools/find_path_test.go"
      provides: "find_path tool tests"
      contains: "TestFindPath"
    - path: "internal/tools/registry.go"
      provides: "find_path registration"
      contains: "find_path"
  key_links:
    - from: "internal/tools/find_path.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryFindPath"
      pattern: "deps\\.DB\\.QueryFindPath"
    - from: "internal/tools/registry.go"
      to: "internal/tools/find_path.go"
      via: "NewFindPathHandler"
      pattern: "NewFindPathHandler"
---

<objective>
Implement the find_path MCP tool for finding the shortest path between two entities.

Purpose: Enable agents to discover how two pieces of knowledge are connected through intermediate relationships. This helps trace connections between concepts and understand the relationship chain.

Output: QueryFindPath database function, find_path tool handler, unit tests, registered in MCP server
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-graph-tools/05-RESEARCH.md
@.planning/phases/05-graph-tools/05-01-SUMMARY.md
@internal/db/queries.go
@internal/tools/traverse.go
@internal/tools/registry.go
@internal/tools/errors.go
@memcp/db.py (lines 544-548 for Python query_find_path pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueryFindPath to query layer</name>
  <files>internal/db/queries.go</files>
  <action>
Add QueryFindPath function to db/queries.go that finds the path between two entities.

**Function signature:**
```go
func (c *Client) QueryFindPath(
    ctx context.Context,
    fromID string,
    toID string,
    maxDepth int,
) ([]models.Entity, error)
```

**SQL pattern (from Python):**
```sql
SELECT * FROM type::record("entity", $from)->relates..{maxDepth}->entity
WHERE id = type::record("entity", $to) LIMIT 1
```

**Implementation notes:**
- Use fmt.Sprintf to inject maxDepth (SurrealDB requires literal)
- Returns path as slice of Entity (intermediate nodes)
- Returns nil slice if no path found (not an error)
- Returns empty slice if path is direct (from == to)
- Wrap error with "find_path: %w" format

**PathResult type (add if needed for query unmarshaling):**
```go
// PathResult wraps the path query response.
type PathResult struct {
    Path []models.Entity `json:"path,omitempty"`
}
```

Note: The Python query returns entities along the path. Test actual SurrealDB output format and adjust unmarshaling as needed.
  </action>
  <verify>
`go build ./...` compiles without errors
  </verify>
  <done>
QueryFindPath function exists in internal/db/queries.go
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement find_path tool handler with tests</name>
  <files>internal/tools/find_path.go, internal/tools/find_path_test.go, internal/tools/registry.go</files>
  <action>
**Create internal/tools/find_path.go:**

Follow the established handler factory pattern.

```go
package tools

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/modelcontextprotocol/go-sdk/mcp"
)

// FindPathInput defines the input schema for the find_path tool.
type FindPathInput struct {
    From     string `json:"from" jsonschema:"required,Starting entity ID"`
    To       string `json:"to" jsonschema:"required,Target entity ID"`
    MaxDepth int    `json:"max_depth,omitempty" jsonschema:"Maximum path length 1-20 (default 5)"`
}

// FindPathResult is the response from the find_path tool.
type FindPathResult struct {
    PathFound bool     `json:"path_found"`
    Path      []string `json:"path,omitempty"`
    Length    int      `json:"length,omitempty"`
    Message   string   `json:"message,omitempty"`
}

// NewFindPathHandler creates the find_path tool handler.
// Finds shortest path between two entities.
func NewFindPathHandler(deps *Dependencies) mcp.ToolHandlerFor[FindPathInput, any] {
    return func(ctx context.Context, req *mcp.CallToolRequest, input FindPathInput) (
        *mcp.CallToolResult, any, error,
    ) {
        // Validate from
        if input.From == "" {
            return ErrorResult("from cannot be empty", "Provide starting entity ID"), nil, nil
        }

        // Validate to
        if input.To == "" {
            return ErrorResult("to cannot be empty", "Provide target entity ID"), nil, nil
        }

        // Set and validate max_depth
        maxDepth := input.MaxDepth
        if maxDepth <= 0 {
            maxDepth = 5
        }
        if maxDepth > 20 {
            return ErrorResult("max_depth must be between 1 and 20", "Reduce max_depth value"), nil, nil
        }

        // Execute path finding
        path, err := deps.DB.QueryFindPath(ctx, input.From, input.To, maxDepth)
        if err != nil {
            deps.Logger.Error("find_path failed", "from", input.From, "to", input.To, "error", err)
            return ErrorResult("Path finding failed", "Database may be unavailable"), nil, nil
        }

        // Handle no path found
        if path == nil || len(path) == 0 {
            result := FindPathResult{
                PathFound: false,
                Message:   fmt.Sprintf("No path found between %s and %s within %d hops", input.From, input.To, maxDepth),
            }
            jsonBytes, _ := json.MarshalIndent(result, "", "  ")
            deps.Logger.Info("find_path: no path", "from", input.From, "to", input.To)
            return TextResult(string(jsonBytes)), nil, nil
        }

        // Build path IDs from entities
        pathIDs := make([]string, len(path))
        for i, e := range path {
            pathIDs[i] = e.ID
        }

        result := FindPathResult{
            PathFound: true,
            Path:      pathIDs,
            Length:    len(path),
        }
        jsonBytes, _ := json.MarshalIndent(result, "", "  ")
        deps.Logger.Info("find_path completed", "from", input.From, "to", input.To, "length", len(path))
        return TextResult(string(jsonBytes)), nil, nil
    }
}
```

**Create internal/tools/find_path_test.go:**

```go
package tools

import (
    "testing"
)

func TestFindPathInput_Validation(t *testing.T) {
    tests := []struct {
        name      string
        input     FindPathInput
        wantErr   string
    }{
        {"empty from", FindPathInput{From: "", To: "target"}, "from"},
        {"empty to", FindPathInput{From: "source", To: ""}, "to"},
        {"valid", FindPathInput{From: "source", To: "target"}, ""},
        {"with depth", FindPathInput{From: "source", To: "target", MaxDepth: 10}, ""},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.wantErr == "from" && tt.input.From != "" {
                t.Errorf("expected empty from")
            }
            if tt.wantErr == "to" && tt.input.To != "" {
                t.Errorf("expected empty to")
            }
            if tt.wantErr == "" && (tt.input.From == "" || tt.input.To == "") {
                t.Errorf("expected valid input")
            }
        })
    }
}

func TestFindPathInput_DefaultMaxDepth(t *testing.T) {
    input := FindPathInput{From: "a", To: "b"}
    if input.MaxDepth != 0 {
        t.Errorf("expected default max_depth 0 (will be set to 5), got %d", input.MaxDepth)
    }
}

func TestFindPathInput_MaxDepthBounds(t *testing.T) {
    input := FindPathInput{From: "a", To: "b", MaxDepth: 25}
    if input.MaxDepth <= 20 {
        t.Errorf("expected max_depth > 20 for bounds test")
    }
}

func TestFindPathResult_NoPath(t *testing.T) {
    result := FindPathResult{
        PathFound: false,
        Message:   "No path found",
    }
    if result.PathFound {
        t.Error("expected path_found false")
    }
    if result.Path != nil {
        t.Error("expected nil path when not found")
    }
}

func TestFindPathResult_WithPath(t *testing.T) {
    result := FindPathResult{
        PathFound: true,
        Path:      []string{"a", "b", "c"},
        Length:    3,
    }
    if !result.PathFound {
        t.Error("expected path_found true")
    }
    if result.Length != 3 {
        t.Errorf("expected length 3, got %d", result.Length)
    }
}
```

**Update internal/tools/registry.go:**

Add find_path tool registration after traverse:

```go
// Find path tool - shortest path between entities
mcp.AddTool(server, &mcp.Tool{
    Name:        "find_path",
    Description: "Find how two pieces of knowledge are connected through intermediate relationships. Use when the user asks 'how is X related to Y' or wants to trace connections between concepts.",
}, NewFindPathHandler(deps))
```
  </action>
  <verify>
`go test ./internal/tools/... -v -run TestFindPath` passes
`go build ./...` compiles successfully
  </verify>
  <done>
- find_path.go exists with NewFindPathHandler
- find_path_test.go exists with validation and result tests
- find_path registered in registry.go
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./...

# Unit tests pass
go test ./internal/tools/... -v -run TestFindPath

# Full test suite still passes
go test ./...

# Verify both graph tools are registered
grep -E "traverse|find_path" internal/tools/registry.go
```
</verification>

<success_criteria>
1. QueryFindPath function in db/queries.go uses SurrealDB path traversal
2. find_path tool handler validates input (from/to required, max_depth 1-20)
3. Tool clearly indicates when no path exists vs error
4. Tests verify input validation and result structure
5. Tool registered and available in MCP server
6. Phase complete: both traverse and find_path tools functional
</success_criteria>

<output>
After completion, create `.planning/phases/05-graph-tools/05-02-SUMMARY.md`
</output>
