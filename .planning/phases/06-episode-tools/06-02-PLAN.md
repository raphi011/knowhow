---
phase: 06-episode-tools
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - internal/db/queries.go
  - internal/tools/episode.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can search episodes by semantic content"
    - "User can filter episodes by time range (before/after)"
    - "User can filter episodes by context"
    - "Search returns episodes ranked by relevance with recency consideration"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "Episode search query"
      contains: "QuerySearchEpisodes"
    - path: "internal/tools/episode.go"
      provides: "Search episodes handler"
      exports: ["NewSearchEpisodesHandler"]
    - path: "internal/tools/registry.go"
      provides: "Tool registration"
      contains: "search_episodes"
  key_links:
    - from: "internal/tools/episode.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QuerySearchEpisodes"
      pattern: "deps\\.DB\\.QuerySearchEpisodes"
    - from: "internal/tools/registry.go"
      to: "internal/tools/episode.go"
      via: "NewSearchEpisodesHandler registration"
      pattern: "NewSearchEpisodesHandler"
---

<objective>
Implement search_episodes tool with hybrid BM25+vector search and time-range filtering.

Purpose: Enable agents to find relevant episodic memories by semantic content with optional time constraints.
Output: Working search_episodes MCP tool with temporal filtering.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-episode-tools/06-CONTEXT.md
@.planning/phases/06-episode-tools/06-RESEARCH.md
@.planning/phases/06-episode-tools/06-01-SUMMARY.md
@internal/models/episode.go
@internal/db/queries.go
@internal/tools/search.go
@internal/tools/registry.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QuerySearchEpisodes to db/queries.go</name>
  <files>internal/db/queries.go</files>
  <action>
Add QuerySearchEpisodes function to db/queries.go:

```go
// QuerySearchEpisodes performs hybrid BM25+vector search on episodes.
// Supports optional time range filtering and context filter.
// Returns episodes ranked by RRF fusion with recency consideration.
func (c *Client) QuerySearchEpisodes(
    ctx context.Context,
    query string,
    embedding []float32,
    timeStart *string,  // ISO 8601 format
    timeEnd *string,    // ISO 8601 format
    contextFilter *string,
    limit int,
) ([]models.Episode, error)
```

**Implementation details:**

1. Build dynamic filter clauses:
   - If timeStart != nil: ` AND timestamp >= <datetime>$time_start`
   - If timeEnd != nil: ` AND timestamp <= <datetime>$time_end`
   - If contextFilter != nil: ` AND context = $context`

2. Use search::rrf() for hybrid search (same pattern as QueryHybridSearch):
   - Vector subquery: `embedding <|{limit*2},40|> $emb` with filters
   - BM25 subquery: `content @0@ $q` with filters
   - RRF k=60

3. Add ORDER BY timestamp DESC within subqueries for recency consideration

4. SQL template:
```sql
SELECT * FROM search::rrf([
    (SELECT id, content, summary, timestamp, metadata, context
     FROM episode
     WHERE embedding <|%d,40|> $emb %s
     ORDER BY timestamp DESC),
    (SELECT id, content, summary, timestamp, metadata, context
     FROM episode
     WHERE content @0@ $q %s
     ORDER BY timestamp DESC)
], $limit, 60)
```

5. Variables map:
   - q: query string
   - emb: embedding vector
   - time_start: optional
   - time_end: optional
   - context: optional
   - limit: int

6. Return []models.Episode (empty slice if no results)

Follow existing QueryHybridSearch pattern for structure.
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: QuerySearchEpisodes exists with correct signature
  </verify>
  <done>
QuerySearchEpisodes added with time filtering and hybrid search
  </done>
</task>

<task type="auto">
  <name>Task 2: Add search_episodes handler to episode.go</name>
  <files>internal/tools/episode.go</files>
  <action>
Add to internal/tools/episode.go:

**Input type:**

```go
type SearchEpisodesInput struct {
    Query     string `json:"query" jsonschema:"required,Semantic search query"`
    TimeStart string `json:"time_start,omitempty" jsonschema:"Filter episodes after this time (ISO 8601, e.g. 2026-01-15T00:00:00Z)"`
    TimeEnd   string `json:"time_end,omitempty" jsonschema:"Filter episodes before this time (ISO 8601)"`
    Context   string `json:"context,omitempty" jsonschema:"Project namespace filter (auto-detected if omitted)"`
    Limit     int    `json:"limit,omitempty" jsonschema:"Max results 1-50 (default 10)"`
}
```

**Handler:**

```go
func NewSearchEpisodesHandler(deps *Dependencies, cfg *config.Config) mcp.ToolHandlerFor[SearchEpisodesInput, any]
```

**Implementation:**

1. Validate query not empty
2. Set limit defaults (10) and validate (1-50)
3. Generate embedding via deps.Embedder.Embed()
4. Prepare time filters:
   - If TimeStart/TimeEnd provided, call ensureTimezone() helper
   - Convert to *string pointers
5. Detect context: explicit > DetectContext(cfg)
6. Call deps.DB.QuerySearchEpisodes()
7. Update access tracking for each result (fire-and-forget)
8. Build response with FULL content (no truncation - user decision):

```go
type EpisodeSearchResult struct {
    Episodes []EpisodeResult `json:"episodes"`
    Count    int             `json:"count"`
}

type EpisodeResult struct {
    ID        string         `json:"id"`
    Content   string         `json:"content"`  // Full content, NOT truncated
    Timestamp string         `json:"timestamp"`
    Summary   *string        `json:"summary,omitempty"`
    Metadata  map[string]any `json:"metadata,omitempty"`
    Context   *string        `json:"context,omitempty"`
}
```

**IMPORTANT:** Return full Content field in search results. Do NOT truncate content to 500 chars.
This is a locked user decision from CONTEXT.md.

**Helper function:**

```go
// ensureTimezone appends Z if timestamp lacks timezone indicator.
func ensureTimezone(ts string) string {
    if ts == "" {
        return ts
    }
    // Check for Z, +, or timezone offset patterns
    if !strings.HasSuffix(ts, "Z") && !strings.Contains(ts[len(ts)-6:], "+") && !strings.Contains(ts[len(ts)-6:], "-") {
        return ts + "Z"
    }
    return ts
}
```

Log query (truncated) and result count.
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: NewSearchEpisodesHandler exists and exported
Check: EpisodeResult.Content is NOT truncated in the response building code
  </verify>
  <done>
search_episodes handler added with time filtering, context detection, and FULL content in results
  </done>
</task>

<task type="auto">
  <name>Task 3: Register search_episodes in registry.go</name>
  <files>internal/tools/registry.go</files>
  <action>
Add search_episodes registration to RegisterAll() in registry.go:

```go
// Search episodes tool - semantic search with time filtering
mcp.AddTool(server, &mcp.Tool{
    Name:        "search_episodes",
    Description: "Search episodic memories by semantic content with optional time range filtering. Use to find past conversations or experiences.",
}, NewSearchEpisodesHandler(deps, cfg))
```

Place after other episode tools (add_episode, get_episode, delete_episode).
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Run: Check via MCP inspector - should list 13 tools total
  </verify>
  <done>
search_episodes registered. Total tools: 13.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./...` passes (existing tests)
3. Manual verification: Start server, use MCP inspector to:
   - Add some test episodes with add_episode
   - Call search_episodes with query "test" - returns matching episodes with FULL content
   - Call search_episodes with time_start filter - filters by time
   - Call search_episodes with context filter - filters by context
</verification>

<success_criteria>
- [ ] QuerySearchEpisodes in db/queries.go with time filtering
- [ ] SearchEpisodesInput and NewSearchEpisodesHandler in episode.go
- [ ] ensureTimezone helper function
- [ ] search_episodes registered in registry.go
- [ ] `go build ./...` passes
- [ ] Semantic search finds relevant episodes
- [ ] Time range filtering works
- [ ] Context filtering works
- [ ] Search results contain FULL episode content (not truncated)
</success_criteria>

<output>
After completion, create `.planning/phases/06-episode-tools/06-02-SUMMARY.md`
</output>
