---
phase: 04-persistence-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/queries.go
  - internal/tools/remember.go
  - internal/tools/registry.go
  - internal/tools/remember_test.go
autonomous: true

must_haves:
  truths:
    - "User can store new entities with auto-generated embeddings"
    - "User can update existing entities with same name (upsert)"
    - "Labels are additively merged on upsert"
    - "Stored entities appear in subsequent searches"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "QueryUpsertEntity function"
      contains: "func.*QueryUpsertEntity"
    - path: "internal/tools/remember.go"
      provides: "remember tool handler for entities"
      exports: ["NewRememberHandler", "RememberInput"]
    - path: "internal/tools/registry.go"
      provides: "remember tool registration"
      contains: "remember"
  key_links:
    - from: "internal/tools/remember.go"
      to: "internal/db/queries.go"
      via: "QueryUpsertEntity call"
      pattern: "deps\\.DB\\.QueryUpsertEntity"
    - from: "internal/tools/remember.go"
      to: "deps.Embedder"
      via: "embedding generation"
      pattern: "deps\\.Embedder\\.Embed"
---

<objective>
Implement the remember tool for storing entities with auto-generated embeddings.

Purpose: Enable users to persist knowledge to the memory graph. This is the core write operation that makes the memory system useful.
Output: Working remember tool that upserts entities with embeddings, accessible via MCP.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-persistence-tools/04-CONTEXT.md
@.planning/phases/04-persistence-tools/04-RESEARCH.md

# Existing patterns
@internal/db/queries.go
@internal/tools/search.go
@internal/tools/registry.go
@internal/models/entity.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueryUpsertEntity function</name>
  <files>internal/db/queries.go</files>
  <action>
Add QueryUpsertEntity to db/queries.go following established pattern:

```go
// QueryUpsertEntity creates or updates an entity by composite ID (context:name).
// Uses SurrealDB UPSERT with array::union for additive label merge.
// Returns the entity after upsert with "action" field indicating created/updated.
func (c *Client) QueryUpsertEntity(
    ctx context.Context,
    id string,           // composite ID: "context:slugified-name" or just "slugified-name"
    entityType string,
    labels []string,
    content string,
    embedding []float32,
    confidence float64,
    source *string,
    context *string,
) (*models.Entity, bool, error)  // returns (entity, wasCreated, error)
```

SQL pattern (from RESEARCH.md):
```sql
-- Check if exists first to determine action
LET $exists = (SELECT count() AS c FROM entity WHERE id = type::record("entity", $id)).c > 0;

UPSERT type::record("entity", $id) SET
    type = $type,
    labels = array::union(labels ?? [], $labels),
    content = $content,
    embedding = $embedding,
    confidence = $confidence,
    source = $source,
    context = $context,
    accessed = time::now(),
    decay_weight = 1.0,
    importance = IF $exists THEN importance ELSE 1.0 END,
    access_count = IF $exists THEN access_count ELSE 0 END
RETURN AFTER;

RETURN !$exists;  -- true if created, false if updated
```

Note: SurrealDB requires 2 queries - one to check existence, one to upsert.
Use transaction or separate queries. Return (entity, wasCreated, error).

Handle nil labels (use empty slice). Handle nil source/context (pass through).
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>QueryUpsertEntity function exists and handles upsert with label merge</done>
</task>

<task type="auto">
  <name>Task 2: Implement remember handler for entities</name>
  <files>internal/tools/remember.go, internal/tools/registry.go</files>
  <action>
Create internal/tools/remember.go with remember tool handler:

**Input structs:**
```go
// RememberInput defines the input schema for the remember tool.
type RememberInput struct {
    Entities  []EntityInput   `json:"entities,omitempty" jsonschema:"Entities to store"`
    Relations []RelationInput `json:"relations,omitempty" jsonschema:"Relations to create (Phase 04-02)"`
    Context   string          `json:"context,omitempty" jsonschema:"Project namespace (auto-detected if omitted)"`
}

type EntityInput struct {
    Name       string   `json:"name" jsonschema:"required,Unique name within context"`
    Content    string   `json:"content" jsonschema:"required,Description or value"`
    Type       string   `json:"type,omitempty" jsonschema:"Entity type (concept, fact, preference)"`
    Labels     []string `json:"labels,omitempty" jsonschema:"Tags for categorization"`
    Confidence float64  `json:"confidence,omitempty" jsonschema:"Confidence score 0-1"`
    Source     string   `json:"source,omitempty" jsonschema:"Where this info came from"`
}

// RelationInput placeholder for Phase 04-02
type RelationInput struct {
    From   string  `json:"from" jsonschema:"required,Source entity name"`
    To     string  `json:"to" jsonschema:"required,Target entity name"`
    Type   string  `json:"type" jsonschema:"required,Relation type"`
    Weight float64 `json:"weight,omitempty" jsonschema:"Relation strength 0-1"`
}
```

**Handler logic:**
1. Validate: at least one entity required, each entity needs name + content
2. Detect context: explicit > config > git origin > cwd
3. For each entity:
   - Generate embedding via deps.Embedder.Embed(ctx, content)
   - Generate composite ID: slugify(context:name) or slugify(name) if no context
   - Call QueryUpsertEntity
   - Collect result with action indicator
4. Return JSON with entities stored and created/updated counts

**Slug function:**
```go
func slugify(name string) string {
    s := strings.ToLower(name)
    s = strings.ReplaceAll(s, " ", "-")
    // Remove non-alphanumeric except hyphens
    return s
}

func generateEntityID(name, context string) string {
    slug := slugify(name)
    if context == "" {
        return slug
    }
    return context + ":" + slug
}
```

**Response format:**
```json
{
  "entities": [...],
  "created": 2,
  "updated": 1
}
```

Do NOT include embeddings in response (strip before marshaling or use separate response type).

Register in registry.go:
```go
mcp.AddTool(server, &mcp.Tool{
    Name:        "remember",
    Description: "Store entities in the knowledge graph with auto-generated embeddings",
}, NewRememberHandler(deps, cfg))
```
  </action>
  <verify>`go build ./...` compiles; tool appears in `tools/list`</verify>
  <done>remember tool registered, accepts entities with name+content, returns stored entities with action indicator</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for remember tool</name>
  <files>internal/tools/remember_test.go</files>
  <action>
Create internal/tools/remember_test.go with unit tests:

1. **TestRememberHandler_Validation** - empty entities returns error
2. **TestRememberHandler_EntityMissingName** - entity without name returns error
3. **TestRememberHandler_EntityMissingContent** - entity without content returns error
4. **TestRememberHandler_SingleEntity** - mock embedder + DB, verify upsert called
5. **TestRememberHandler_MultipleEntities** - verify all entities processed
6. **TestRememberInput_Schema** - verify JSON schema generation works

Follow existing test patterns from search_test.go. Use mock DB and embedder.

For integration tests (build tag: integration):
6. **TestRememberHandler_Integration** - actually store entity, then search for it
7. **TestRememberHandler_UpsertMergesLabels** - store twice with different labels, verify merge
  </action>
  <verify>`go test ./internal/tools/... -v` passes all unit tests</verify>
  <done>Remember tool has unit test coverage for validation and happy path</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` - compiles without errors
2. `go test ./internal/tools/... -v` - all tests pass
3. `go test ./internal/db/... -v` - all tests pass
4. Tool registration: remember appears in tools/list
</verification>

<success_criteria>
- QueryUpsertEntity function in db/queries.go with UPSERT + label merge
- remember handler in tools/remember.go accepting EntityInput array
- Tool registered in registry.go
- Embeddings generated for each entity before storage
- Response excludes embeddings, includes created/updated counts
- Unit tests pass for validation and happy path
</success_criteria>

<output>
After completion, create `.planning/phases/04-persistence-tools/04-01-SUMMARY.md`
</output>
