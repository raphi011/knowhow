---
phase: 02-mcp-server
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/tools/deps.go
  - internal/tools/registry.go
  - internal/tools/errors.go
  - internal/tools/ping.go
  - internal/tools/tools_test.go
  - cmd/memcp/main.go
autonomous: true

must_haves:
  truths:
    - "Claude Code can list available tools"
    - "Tool handlers receive typed, validated input"
    - "Tool errors include recovery hints"
    - "All tool calls are logged with timing"
  artifacts:
    - path: "internal/tools/deps.go"
      provides: "Dependencies struct for service injection"
      exports: ["Dependencies"]
    - path: "internal/tools/registry.go"
      provides: "Tool registration function"
      exports: ["RegisterAll"]
    - path: "internal/tools/errors.go"
      provides: "Error result helpers"
      exports: ["ErrorResult", "TextResult"]
    - path: "internal/tools/ping.go"
      provides: "Placeholder ping tool for testing"
      exports: ["PingInput", "NewPingHandler"]
  key_links:
    - from: "cmd/memcp/main.go"
      to: "internal/tools"
      via: "tools.RegisterAll(srv.MCPServer(), deps)"
      pattern: "tools\\.RegisterAll\\("
    - from: "internal/tools/registry.go"
      to: "mcp.AddTool"
      via: "SDK tool registration"
      pattern: "mcp\\.AddTool\\("
---

<objective>
Create tool registration framework with dependency injection, error helpers, and a placeholder ping tool.

Purpose: Establish the pattern all future tools will follow (Phase 3-8)
Output: Framework ready for business logic tools, verified by ping tool
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-server/02-CONTEXT.md
@.planning/phases/02-mcp-server/02-RESEARCH.md
@.planning/phases/02-mcp-server/02-01-SUMMARY.md

# Existing code
@internal/server/server.go
@internal/db/client.go
@internal/embedding/embedder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dependencies and Error Helpers</name>
  <files>internal/tools/deps.go, internal/tools/errors.go</files>
  <action>
Create tool infrastructure in `internal/tools/`:

**deps.go:**
```go
// Dependencies holds shared services for tool handlers.
// Passed to handler factories via closure capture.
type Dependencies struct {
    DB       *db.Client
    Embedder embedding.Embedder
    Logger   *slog.Logger
}
```

**errors.go:**
- `ErrorResult(msg, hint string) *mcp.CallToolResult` - creates error result with IsError=true
  - If hint non-empty: format as "{msg}. {hint}"
  - Returns TextContent with the message
- `TextResult(text string) *mcp.CallToolResult` - creates success result with text
- `FormatResults(items []string) string` - joins items with newlines for list output

Per CONTEXT.md: minimal error messages with recovery hints.
Examples:
- `ErrorResult("Entity not found", "Try search first")`
- `ErrorResult("Query cannot be empty", "")`
- `ErrorResult("Database error", "Please retry")`
  </action>
  <verify>
```bash
go build ./internal/tools/...
go vet ./internal/tools/...
```
  </verify>
  <done>deps.go and errors.go compile, provide Dependencies struct and result helpers</done>
</task>

<task type="auto">
  <name>Task 2: Ping Tool and Registry</name>
  <files>internal/tools/ping.go, internal/tools/registry.go</files>
  <action>
Create placeholder tool and registration:

**ping.go:**
- `PingInput` struct with optional `Echo string` field (json:"echo,omitempty", jsonschema:"description=Text to echo back")
- `NewPingHandler(deps *Dependencies) mcp.ToolHandlerFor[PingInput, any]`
  - Logs call via deps.Logger
  - If Echo provided: return TextResult with echo text
  - If no Echo: return TextResult with "pong"
  - No errors possible, simple test tool

**registry.go:**
- `RegisterAll(server *mcp.Server, deps *Dependencies)`
  - Registers ping tool with:
    - Name: "ping"
    - Description: "Test tool - responds with pong or echoes input"
  - Use `mcp.AddTool(server, &mcp.Tool{...}, NewPingHandler(deps))`

This establishes the pattern. Future phases add more tools via the same pattern.

Import paths:
- `github.com/modelcontextprotocol/go-sdk/mcp`
- `memcp-go/internal/db`
- `memcp-go/internal/embedding`
  </action>
  <verify>
```bash
go build ./internal/tools/...
go vet ./internal/tools/...
```
  </verify>
  <done>Ping tool and RegisterAll compile, demonstrate handler factory pattern</done>
</task>

<task type="auto">
  <name>Task 3: Wire Tools into Main and Test</name>
  <files>cmd/memcp/main.go, internal/tools/tools_test.go</files>
  <action>
**Update cmd/memcp/main.go:**
1. Import `memcp-go/internal/tools`
2. After server creation and Setup(), before Run():
   ```go
   deps := &tools.Dependencies{
       DB:       dbClient,
       Embedder: embedder,
       Logger:   logger,
   }
   tools.RegisterAll(srv.MCPServer(), deps)
   ```
3. Log number of registered tools (can hardcode "1 tool" for now)

**Create internal/tools/tools_test.go:**
- Build tag: `//go:build integration`
- `TestPingTool` - uses in-memory transport:
  1. Create server, register tools with nil deps (ping doesn't use them)
  2. Start server on in-memory transport
  3. Initialize client
  4. Call tools/list - verify "ping" in response
  5. Call tools/call with name="ping" - verify "pong" response
  6. Call tools/call with name="ping", args={"echo": "hello"} - verify "hello" response

Test verifies:
- Tool registration works
- Handler receives typed input
- Response formatting correct
  </action>
  <verify>
```bash
go build ./cmd/memcp/...
go test ./internal/tools/... -tags=integration -v -count=1
```
  </verify>
  <done>Main wires tools, ping tool callable via in-memory transport test</done>
</task>

</tasks>

<verification>
```bash
# All packages compile
go build ./...
go vet ./...

# Tool tests pass
go test ./internal/tools/... -tags=integration -v

# Full server tests pass
go test ./internal/server/... -tags=integration -v

# Binary builds
go build -o ./cmd/memcp/memcp ./cmd/memcp/
```
</verification>

<success_criteria>
- Dependencies struct provides DB, Embedder, Logger injection
- ErrorResult/TextResult helpers create properly formatted responses
- RegisterAll registers tools with MCP server
- Ping tool demonstrates complete handler pattern
- tools/list returns ping tool
- tools/call ping returns expected responses
- main.go wires everything together
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-server/02-02-SUMMARY.md`
</output>
