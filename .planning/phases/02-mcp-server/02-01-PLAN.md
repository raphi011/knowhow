---
phase: 02-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/memcp/main.go
  - internal/server/server.go
  - internal/server/middleware.go
autonomous: true

must_haves:
  truths:
    - "Server starts and logs version/config info"
    - "Server connects to SurrealDB or exits with error"
    - "Server runs on stdio transport"
    - "Server shuts down gracefully on SIGTERM/SIGINT"
  artifacts:
    - path: "cmd/memcp/main.go"
      provides: "Application entry point with composition root"
      contains: "func main()"
    - path: "internal/server/server.go"
      provides: "MCP server wrapper with lifecycle management"
      exports: ["New", "Run", "MCPServer"]
    - path: "internal/server/middleware.go"
      provides: "Request logging middleware"
      exports: ["LoggingMiddleware"]
  key_links:
    - from: "cmd/memcp/main.go"
      to: "internal/server"
      via: "server.New() and server.Run()"
      pattern: "server\\.New\\(|server\\.Run\\("
    - from: "cmd/memcp/main.go"
      to: "internal/db"
      via: "db.NewClient() at startup"
      pattern: "db\\.NewClient\\("
---

<objective>
Create MCP server with stdio transport, startup logging, graceful shutdown, and DB connection validation.

Purpose: Establish the foundation that all tools will plug into
Output: Running server that Claude Code can connect to (no tools yet)
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-server/02-CONTEXT.md
@.planning/phases/02-mcp-server/02-RESEARCH.md

# Existing code from Phase 1
@internal/config/config.go
@internal/config/logging.go
@internal/db/client.go
@internal/embedding/embedder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP Server Wrapper and Middleware</name>
  <files>internal/server/server.go, internal/server/middleware.go</files>
  <action>
Create MCP server wrapper in `internal/server/`:

**server.go:**
- `Server` struct wrapping `*mcp.Server` with logger
- `New(version string, logger *slog.Logger) *Server` - creates server with Implementation{Name: "memcp", Version: version}
- `Run(ctx context.Context) error` - runs on `mcp.StdioTransport{}`
- `MCPServer() *mcp.Server` - returns underlying server for tool registration
- `Setup()` - adds middleware to server

Use `github.com/modelcontextprotocol/go-sdk/mcp` package.

**middleware.go:**
- `LoggingMiddleware(logger *slog.Logger) mcp.Middleware` - logs all requests with:
  - Request method (from req type inspection)
  - Duration in milliseconds
  - Error status if any
- Log slow requests (>100ms) at WARN level
- Truncate logged arguments to 200 chars

AVOID: Logging to stdout (corrupts JSON-RPC). Use stderr via the provided slog logger.
  </action>
  <verify>
```bash
go build ./internal/server/...
go vet ./internal/server/...
```
  </verify>
  <done>Server and middleware packages compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Main Entry Point with Composition Root</name>
  <files>cmd/memcp/main.go</files>
  <action>
Create application entry point in `cmd/memcp/main.go`:

1. **Config and logging:**
   - Load config via `config.Load()`
   - Setup logger via `config.SetupLogger()`
   - Log startup info: version, SurrealDB URL, embedding model

2. **Signal handling:**
   - Create context with cancel
   - Listen for SIGTERM/SIGINT
   - Cancel context on signal

3. **Database connection:**
   - Create db.Config from config.Config (map field names)
   - Call `db.NewClient()` with context
   - If error: log and `os.Exit(1)` (no degraded mode per CONTEXT.md)
   - Defer `dbClient.Close(ctx)`
   - Call `dbClient.InitSchema(ctx)` - exit on error

4. **Embedder creation:**
   - Call `embedding.DefaultOllama()`
   - Log embedder model name
   - If error: log and `os.Exit(1)`

5. **Server creation and run:**
   - Create server via `server.New(version, logger)`
   - Call `srv.Setup()` to add middleware
   - Log "server ready, awaiting connections"
   - Call `srv.Run(ctx)` - blocks until disconnect/signal
   - On error (and ctx not cancelled): log and `os.Exit(1)`
   - Log "shutdown complete"

Use const `version = "0.1.0"`.

AVOID: Any fmt.Print or log.Print - only use slog logger.
  </action>
  <verify>
```bash
go build ./cmd/memcp/...
go vet ./cmd/memcp/...
# Test that binary starts (will fail fast without DB, but should compile)
./cmd/memcp/memcp 2>&1 | head -5 || true
```
  </verify>
  <done>Binary compiles and attempts startup (may fail at DB connection, that's expected without running SurrealDB)</done>
</task>

<task type="auto">
  <name>Task 3: Integration Test - Server Startup</name>
  <files>internal/server/server_test.go</files>
  <action>
Create integration test for server lifecycle:

**server_test.go:**
- `TestServerCreation` - verifies New() creates valid server
- `TestServerWithInMemoryTransport` - uses mcp.NewInMemoryTransport() to test:
  - Server starts without error
  - Server responds to initialize request
  - Server lists empty tools (none registered yet)
  - Server shuts down cleanly when context cancelled

Skip DB/embedder for these tests - just test the MCP layer.

Use build tag `//go:build integration` so unit tests skip this.

Pattern from RESEARCH.md:
```go
clientTransport, serverTransport := mcp.NewInMemoryTransport()
go srv.MCPServer().Run(ctx, serverTransport)
// Use clientTransport to send requests
```
  </action>
  <verify>
```bash
go test ./internal/server/... -tags=integration -v -count=1
```
  </verify>
  <done>Server creates, starts on in-memory transport, responds to initialize, shuts down cleanly</done>
</task>

</tasks>

<verification>
```bash
# All packages compile
go build ./...
go vet ./...

# Server tests pass
go test ./internal/server/... -tags=integration -v

# Binary exists and attempts startup
ls -la ./cmd/memcp/memcp 2>/dev/null || go build -o ./cmd/memcp/memcp ./cmd/memcp/
```
</verification>

<success_criteria>
- cmd/memcp/main.go compiles and runs (fails at DB if not available)
- internal/server package provides Server wrapper with Run(), Setup(), MCPServer()
- internal/server/middleware.go provides LoggingMiddleware
- Server tests pass with in-memory transport
- No stdout logging (only stderr via slog)
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-server/02-01-SUMMARY.md`
</output>
