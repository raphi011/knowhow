---
phase: 08-maintenance-tools
plan: 03
type: gap_closure
wave: 3
depends_on: ["08-02"]
files_modified:
  - internal/db/queries_test.go
autonomous: true

must_haves:
  truths:
    - "All 25 query functions in db/queries.go have integration test coverage"
    - "Tests cover relation, graph traversal, search, link, and access update queries"
    - "Per-test setup/teardown ensures isolation"
  artifacts:
    - path: "internal/db/queries_test.go"
      provides: "Complete query function integration tests"
      contains: ["TestQueryCreateRelation", "TestQueryTraverse", "TestQueryFindPath", "TestQuerySearchEpisodes", "TestQuerySearchProcedures", "TestQueryListProcedures", "TestQueryLinkEntityToEpisode", "TestQueryGetLinkedEntities", "TestQueryUpdateAccess", "TestQueryUpdateEpisodeAccess", "TestQueryUpdateProcedureAccess"]
  key_links:
    - from: "internal/db/queries_test.go"
      to: "internal/db/queries.go"
      via: "Direct function calls"
      pattern: "client\\.Query"
---

<objective>
Close TEST-01 gap by adding 11 missing query function tests.

Purpose: Achieve 100% integration test coverage for query functions.
Gap source: Phase 08-VERIFICATION.md identified 11 untested functions.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/08-maintenance-tools/08-VERIFICATION.md
@internal/db/queries.go
@internal/db/queries_test.go
@internal/models/entity.go
@internal/models/episode.go
@internal/models/procedure.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add relation query tests (QueryCreateRelation, QueryGetLinkedEntities)</name>
  <files>internal/db/queries_test.go</files>
  <action>
Add tests for relation query functions at end of file:

```go
// ========== Relation Query Tests ==========

func TestQueryCreateRelation(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_rel_%d", time.Now().UnixNano())
    t.Cleanup(func() {
        cleanupEntities(t, client, ctx, prefix)
        // Also cleanup relations
        _, _ = client.Query(ctx, `DELETE relates WHERE in.id CONTAINS $prefix OR out.id CONTAINS $prefix`, map[string]any{"prefix": prefix})
    })

    // Create two entities
    _, _, err := client.QueryUpsertEntity(ctx, prefix+"_from", "concept", nil, "From entity", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_to", "concept", nil, "To entity", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    // Create relation
    err = client.QueryCreateRelation(ctx, prefix+"_from", "relates_to", prefix+"_to", 0.8)
    require.NoError(t, err, "should create relation")

    // Create relation again (upsert - should not error)
    err = client.QueryCreateRelation(ctx, prefix+"_from", "relates_to", prefix+"_to", 0.9)
    require.NoError(t, err, "should upsert relation")

    // Create relation to non-existent entity
    err = client.QueryCreateRelation(ctx, prefix+"_from", "relates_to", "nonexistent_xyz", 0.5)
    assert.Error(t, err, "should fail for non-existent target")
}

func TestQueryGetLinkedEntities(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_linked_%d", time.Now().UnixNano())
    t.Cleanup(func() {
        cleanupEntities(t, client, ctx, prefix)
        cleanupEpisodes(t, client, ctx, prefix)
        // Cleanup extracted_from relations
        _, _ = client.Query(ctx, `DELETE extracted_from WHERE out.id CONTAINS $prefix`, map[string]any{"prefix": prefix})
    })

    // Create episode
    timestamp := time.Now().Format(time.RFC3339)
    _, err := client.QueryCreateEpisode(ctx, prefix+"_ep", "Episode content", testEmbedding(), timestamp, nil, nil, nil)
    require.NoError(t, err)

    // Create entities and link to episode
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_e1", "concept", nil, "Entity 1", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_e2", "concept", nil, "Entity 2", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    err = client.QueryLinkEntityToEpisode(ctx, prefix+"_e1", prefix+"_ep", 0, 0.9)
    require.NoError(t, err)
    err = client.QueryLinkEntityToEpisode(ctx, prefix+"_e2", prefix+"_ep", 1, 0.8)
    require.NoError(t, err)

    // Get linked entities
    entities, err := client.QueryGetLinkedEntities(ctx, prefix+"_ep")
    require.NoError(t, err)
    assert.Len(t, entities, 2, "should find 2 linked entities")

    // Get linked for episode with no links
    entities, err = client.QueryGetLinkedEntities(ctx, "nonexistent_ep_xyz")
    require.NoError(t, err)
    assert.Empty(t, entities, "should return empty for non-existent episode")
}
```
  </action>
  <verify>
Run: `go test ./internal/db/... -v -run "TestQueryCreateRelation|TestQueryGetLinkedEntities"` - tests pass
  </verify>
  <done>
Relation query tests added (QueryCreateRelation, QueryGetLinkedEntities)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add graph traversal tests (QueryTraverse, QueryFindPath)</name>
  <files>internal/db/queries_test.go</files>
  <action>
Add tests for graph traversal query functions:

```go
// ========== Graph Traversal Query Tests ==========

func TestQueryTraverse(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_traverse_%d", time.Now().UnixNano())
    t.Cleanup(func() {
        cleanupEntities(t, client, ctx, prefix)
        _, _ = client.Query(ctx, `DELETE relates WHERE in.id CONTAINS $prefix OR out.id CONTAINS $prefix`, map[string]any{"prefix": prefix})
    })

    // Create chain: A -> B -> C
    _, _, err := client.QueryUpsertEntity(ctx, prefix+"_a", "concept", nil, "A", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_b", "concept", nil, "B", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_c", "concept", nil, "C", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    err = client.QueryCreateRelation(ctx, prefix+"_a", "connects", prefix+"_b", 1.0)
    require.NoError(t, err)
    err = client.QueryCreateRelation(ctx, prefix+"_b", "connects", prefix+"_c", 1.0)
    require.NoError(t, err)

    // Traverse from A with depth 1
    results, err := client.QueryTraverse(ctx, prefix+"_a", 1, nil)
    require.NoError(t, err)
    assert.NotEmpty(t, results, "should find traverse results")

    // Traverse from A with depth 2 (should reach C)
    results, err = client.QueryTraverse(ctx, prefix+"_a", 2, nil)
    require.NoError(t, err)
    assert.NotEmpty(t, results, "should find deeper traverse results")

    // Traverse with relation type filter
    results, err = client.QueryTraverse(ctx, prefix+"_a", 2, []string{"connects"})
    require.NoError(t, err)
    assert.NotEmpty(t, results, "should find results with type filter")

    // Traverse with non-matching relation type
    results, err = client.QueryTraverse(ctx, prefix+"_a", 2, []string{"unrelated_type"})
    require.NoError(t, err)
    // Connected should be empty when filtering by non-existent type
}

func TestQueryFindPath(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_path_%d", time.Now().UnixNano())
    t.Cleanup(func() {
        cleanupEntities(t, client, ctx, prefix)
        _, _ = client.Query(ctx, `DELETE relates WHERE in.id CONTAINS $prefix OR out.id CONTAINS $prefix`, map[string]any{"prefix": prefix})
    })

    // Create path: X -> Y -> Z
    _, _, err := client.QueryUpsertEntity(ctx, prefix+"_x", "concept", nil, "X", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_y", "concept", nil, "Y", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_z", "concept", nil, "Z", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    err = client.QueryCreateRelation(ctx, prefix+"_x", "links", prefix+"_y", 1.0)
    require.NoError(t, err)
    err = client.QueryCreateRelation(ctx, prefix+"_y", "links", prefix+"_z", 1.0)
    require.NoError(t, err)

    // Find path from X to Z (depth 2)
    path, err := client.QueryFindPath(ctx, prefix+"_x", prefix+"_z", 2)
    require.NoError(t, err)
    // Path traversal returns intermediate nodes or target
    // The actual result depends on SurrealDB path query semantics

    // Find path with insufficient depth
    path, err = client.QueryFindPath(ctx, prefix+"_x", prefix+"_z", 1)
    require.NoError(t, err)
    // May be nil or empty if path requires depth 2

    // Find path to non-existent entity
    path, err = client.QueryFindPath(ctx, prefix+"_x", "nonexistent_xyz", 5)
    require.NoError(t, err)
    assert.Nil(t, path, "should return nil for no path found")

    _ = path // Use variable
}
```
  </action>
  <verify>
Run: `go test ./internal/db/... -v -run "TestQueryTraverse|TestQueryFindPath"` - tests pass
  </verify>
  <done>
Graph traversal query tests added (QueryTraverse, QueryFindPath)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add search and list query tests</name>
  <files>internal/db/queries_test.go</files>
  <action>
Add tests for search and list query functions:

```go
// ========== Search Query Tests ==========

func TestQuerySearchEpisodes(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_search_ep_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupEpisodes(t, client, ctx, prefix) })

    testCtx := "search-ep-test-ctx"
    now := time.Now()

    // Create episodes at different times
    _, err := client.QueryCreateEpisode(ctx, prefix+"_recent", "Recent episode about coding", testEmbedding(), now.Format(time.RFC3339), nil, nil, &testCtx)
    require.NoError(t, err)
    _, err = client.QueryCreateEpisode(ctx, prefix+"_old", "Old episode about testing", differentEmbedding(), now.Add(-48*time.Hour).Format(time.RFC3339), nil, nil, &testCtx)
    require.NoError(t, err)

    // Basic search
    results, err := client.QuerySearchEpisodes(ctx, "coding", testEmbedding(), nil, nil, &testCtx, 10)
    require.NoError(t, err)
    assert.NotEmpty(t, results, "should find episodes")

    // Search with time range (last 24 hours)
    timeStart := now.Add(-24 * time.Hour).Format(time.RFC3339)
    results, err = client.QuerySearchEpisodes(ctx, "episode", testEmbedding(), &timeStart, nil, &testCtx, 10)
    require.NoError(t, err)
    // Should find recent episode only

    // Search with context filter
    otherCtx := "other-context"
    results, err = client.QuerySearchEpisodes(ctx, "episode", testEmbedding(), nil, nil, &otherCtx, 10)
    require.NoError(t, err)
    assert.Empty(t, results, "should find nothing in different context")
}

func TestQuerySearchProcedures(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_search_proc_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupProcedures(t, client, ctx, prefix) })

    testCtx := "search-proc-test-ctx"

    // Create procedures with labels
    _, err := client.QueryCreateProcedure(ctx, prefix+"_deploy", "Deploy Application", "Steps to deploy", nil, testEmbedding(), []string{"devops", "prod"}, &testCtx)
    require.NoError(t, err)
    _, err = client.QueryCreateProcedure(ctx, prefix+"_test", "Run Tests", "Steps to run tests", nil, differentEmbedding(), []string{"devops", "ci"}, &testCtx)
    require.NoError(t, err)

    // Basic search
    results, err := client.QuerySearchProcedures(ctx, "deploy", testEmbedding(), nil, &testCtx, 10)
    require.NoError(t, err)
    assert.NotEmpty(t, results, "should find procedures")

    // Search with label filter
    results, err = client.QuerySearchProcedures(ctx, "steps", testEmbedding(), []string{"prod"}, &testCtx, 10)
    require.NoError(t, err)
    // Should find deploy procedure (has prod label)

    // Search with non-matching label
    results, err = client.QuerySearchProcedures(ctx, "steps", testEmbedding(), []string{"nonexistent_label"}, &testCtx, 10)
    require.NoError(t, err)
    assert.Empty(t, results, "should find nothing with non-matching label")
}

func TestQueryListProcedures(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_list_proc_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupProcedures(t, client, ctx, prefix) })

    testCtx := "list-proc-test-ctx"

    // Create procedures
    _, err := client.QueryCreateProcedure(ctx, prefix+"_a", "Procedure A", "Desc A", nil, testEmbedding(), nil, &testCtx)
    require.NoError(t, err)
    _, err = client.QueryCreateProcedure(ctx, prefix+"_b", "Procedure B", "Desc B", nil, testEmbedding(), nil, &testCtx)
    require.NoError(t, err)

    // List with context filter
    results, err := client.QueryListProcedures(ctx, &testCtx, 100)
    require.NoError(t, err)
    assert.GreaterOrEqual(t, len(results), 2, "should find at least 2 procedures")

    // List with limit
    results, err = client.QueryListProcedures(ctx, &testCtx, 1)
    require.NoError(t, err)
    assert.Len(t, results, 1, "should respect limit")

    // List with different context (empty result)
    otherCtx := "other-context-xyz"
    results, err = client.QueryListProcedures(ctx, &otherCtx, 100)
    require.NoError(t, err)
    assert.Empty(t, results, "should find nothing in different context")

    // List all (no context filter)
    results, err = client.QueryListProcedures(ctx, nil, 100)
    require.NoError(t, err)
    assert.GreaterOrEqual(t, len(results), 2, "should find procedures without context filter")
}
```
  </action>
  <verify>
Run: `go test ./internal/db/... -v -run "TestQuerySearchEpisodes|TestQuerySearchProcedures|TestQueryListProcedures"` - tests pass
  </verify>
  <done>
Search and list query tests added (QuerySearchEpisodes, QuerySearchProcedures, QueryListProcedures)
  </done>
</task>

<task type="auto">
  <name>Task 4: Add link and access update tests</name>
  <files>internal/db/queries_test.go</files>
  <action>
Add tests for link and access update query functions:

```go
// ========== Link Query Tests ==========

func TestQueryLinkEntityToEpisode(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_link_%d", time.Now().UnixNano())
    t.Cleanup(func() {
        cleanupEntities(t, client, ctx, prefix)
        cleanupEpisodes(t, client, ctx, prefix)
        _, _ = client.Query(ctx, `DELETE extracted_from WHERE out.id CONTAINS $prefix`, map[string]any{"prefix": prefix})
    })

    // Create episode and entity
    timestamp := time.Now().Format(time.RFC3339)
    _, err := client.QueryCreateEpisode(ctx, prefix+"_ep", "Episode content", testEmbedding(), timestamp, nil, nil, nil)
    require.NoError(t, err)
    _, _, err = client.QueryUpsertEntity(ctx, prefix+"_entity", "concept", nil, "Entity content", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    // Link entity to episode
    err = client.QueryLinkEntityToEpisode(ctx, prefix+"_entity", prefix+"_ep", 0, 0.95)
    require.NoError(t, err, "should create link")

    // Link again (should upsert or create duplicate - depends on schema)
    err = client.QueryLinkEntityToEpisode(ctx, prefix+"_entity", prefix+"_ep", 1, 0.85)
    require.NoError(t, err, "should handle duplicate link")
}

// ========== Access Update Query Tests ==========

func TestQueryUpdateAccess(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_access_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupEntities(t, client, ctx, prefix) })

    id := prefix + "_entity"

    // Create entity
    _, _, err := client.QueryUpsertEntity(ctx, id, "concept", nil, "Content", testEmbedding(), 1.0, nil, nil)
    require.NoError(t, err)

    // Get initial state
    entity, err := client.QueryGetEntity(ctx, id)
    require.NoError(t, err)
    initialAccess := entity.AccessCount

    // Update access
    err = client.QueryUpdateAccess(ctx, id)
    require.NoError(t, err, "should update access")

    // Verify access_count incremented
    entity, err = client.QueryGetEntity(ctx, id)
    require.NoError(t, err)
    assert.Equal(t, initialAccess+1, entity.AccessCount, "access_count should increment")
    assert.Equal(t, 1.0, entity.DecayWeight, "decay_weight should reset to 1.0")

    // Update access for non-existent entity (no error, just no-op)
    err = client.QueryUpdateAccess(ctx, "nonexistent_entity_xyz")
    require.NoError(t, err, "should not error for non-existent entity")
}

func TestQueryUpdateEpisodeAccess(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_ep_access_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupEpisodes(t, client, ctx, prefix) })

    id := prefix + "_ep"
    timestamp := time.Now().Format(time.RFC3339)

    // Create episode
    _, err := client.QueryCreateEpisode(ctx, id, "Content", testEmbedding(), timestamp, nil, nil, nil)
    require.NoError(t, err)

    // Get initial state
    episode, err := client.QueryGetEpisode(ctx, id)
    require.NoError(t, err)
    initialAccess := episode.AccessCount

    // Update access
    err = client.QueryUpdateEpisodeAccess(ctx, id)
    require.NoError(t, err, "should update episode access")

    // Verify access_count incremented
    episode, err = client.QueryGetEpisode(ctx, id)
    require.NoError(t, err)
    assert.Equal(t, initialAccess+1, episode.AccessCount, "access_count should increment")

    // Update access for non-existent episode (no error, just no-op)
    err = client.QueryUpdateEpisodeAccess(ctx, "nonexistent_ep_xyz")
    require.NoError(t, err, "should not error for non-existent episode")
}

func TestQueryUpdateProcedureAccess(t *testing.T) {
    client, ctx := testClient(t)
    prefix := fmt.Sprintf("test_proc_access_%d", time.Now().UnixNano())
    t.Cleanup(func() { cleanupProcedures(t, client, ctx, prefix) })

    id := prefix + "_proc"

    // Create procedure
    _, err := client.QueryCreateProcedure(ctx, id, "Test Proc", "Description", nil, testEmbedding(), nil, nil)
    require.NoError(t, err)

    // Get initial state
    proc, err := client.QueryGetProcedure(ctx, id)
    require.NoError(t, err)
    initialAccess := proc.AccessCount

    // Update access
    err = client.QueryUpdateProcedureAccess(ctx, id)
    require.NoError(t, err, "should update procedure access")

    // Verify access_count incremented
    proc, err = client.QueryGetProcedure(ctx, id)
    require.NoError(t, err)
    assert.Equal(t, initialAccess+1, proc.AccessCount, "access_count should increment")

    // Update access for non-existent procedure (no error, just no-op)
    err = client.QueryUpdateProcedureAccess(ctx, "nonexistent_proc_xyz")
    require.NoError(t, err, "should not error for non-existent procedure")
}
```
  </action>
  <verify>
Run: `go test ./internal/db/... -v -run "TestQueryLinkEntityToEpisode|TestQueryUpdateAccess|TestQueryUpdateEpisodeAccess|TestQueryUpdateProcedureAccess"` - tests pass
  </verify>
  <done>
Link and access update query tests added (QueryLinkEntityToEpisode, QueryUpdateAccess, QueryUpdateEpisodeAccess, QueryUpdateProcedureAccess)
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./internal/db/... -v` passes (all 27 tests)
3. Test coverage now includes all 25 query functions:
   - Entity: upsert, get, delete, search (4)
   - Labels/types: list_labels, list_types (2)
   - Episode: create, get, delete, search (4)
   - Procedure: create, get, delete, search, list (5)
   - Relations: create_relation, get_linked_entities (2)
   - Graph: traverse, find_path (2)
   - Links: link_entity_to_episode (1)
   - Access: update_access, update_episode_access, update_procedure_access (3)
   - Maintenance: apply_decay, find_similar_pairs (2)
</verification>

<success_criteria>
- [ ] TestQueryCreateRelation verifies relation creation and upsert
- [ ] TestQueryGetLinkedEntities verifies entity-episode link retrieval
- [ ] TestQueryTraverse verifies graph traversal at multiple depths
- [ ] TestQueryFindPath verifies path finding between entities
- [ ] TestQuerySearchEpisodes verifies hybrid search with time filters
- [ ] TestQuerySearchProcedures verifies hybrid search with label filters
- [ ] TestQueryListProcedures verifies listing with context filter and limit
- [ ] TestQueryLinkEntityToEpisode verifies extracted_from relation creation
- [ ] TestQueryUpdateAccess verifies access_count increment and decay_weight reset
- [ ] TestQueryUpdateEpisodeAccess verifies episode access tracking
- [ ] TestQueryUpdateProcedureAccess verifies procedure access tracking
- [ ] All 27 tests pass with real SurrealDB
</success_criteria>

<output>
After completion, create `.planning/phases/08-maintenance-tools/08-03-SUMMARY.md`
Then update VERIFICATION.md to reflect gap closure.
</output>
