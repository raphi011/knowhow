---
phase: 08-maintenance-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/models/reflect.go
  - internal/db/queries.go
  - internal/tools/reflect.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "User can apply decay to unused entities via reflect tool with action=decay"
    - "User can identify similar entity pairs via reflect tool with action=similar"
    - "Decay reduces both decay_weight and importance_score for stale entities"
    - "Similar pairs detection uses cosine similarity on embeddings"
    - "Both actions support dry_run mode for preview"
    - "Both actions support context scoping with global flag"
  artifacts:
    - path: "internal/models/reflect.go"
      provides: "Reflect result types"
      exports: ["DecayResult", "DecayedEntity", "SimilarPairsResult", "SimilarPair"]
    - path: "internal/db/queries.go"
      provides: "Maintenance query functions"
      contains: ["QueryApplyDecay", "QueryFindSimilarPairs"]
    - path: "internal/tools/reflect.go"
      provides: "Reflect tool handler"
      exports: ["NewReflectHandler"]
    - path: "internal/tools/registry.go"
      provides: "Tool registration"
      contains: "reflect"
  key_links:
    - from: "internal/tools/reflect.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryApplyDecay"
      pattern: "deps\\.DB\\.QueryApplyDecay"
    - from: "internal/tools/reflect.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryFindSimilarPairs"
      pattern: "deps\\.DB\\.QueryFindSimilarPairs"
    - from: "internal/tools/registry.go"
      to: "internal/tools/reflect.go"
      via: "NewReflectHandler registration"
      pattern: "NewReflectHandler"
---

<objective>
Implement the reflect tool for memory maintenance: decay and similar pairs detection.

Purpose: Enable agents to maintain memory store health by decaying stale entities and identifying potential duplicates.
Output: Single MCP tool with action parameter supporting decay and similar operations.
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-maintenance-tools/08-CONTEXT.md
@.planning/phases/08-maintenance-tools/08-RESEARCH.md
@internal/models/entity.go
@internal/db/queries.go
@internal/tools/search.go
@internal/tools/registry.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reflect model types in models/reflect.go</name>
  <files>internal/models/reflect.go</files>
  <action>
Create internal/models/reflect.go with result types for the reflect tool:

```go
package models

// DecayedEntity represents an entity affected by decay.
type DecayedEntity struct {
    ID              string  `json:"id"`
    Name            string  `json:"name"`
    OldDecayWeight  float64 `json:"old_decay_weight"`
    NewDecayWeight  float64 `json:"new_decay_weight"`
    OldImportance   float64 `json:"old_importance"`
    NewImportance   float64 `json:"new_importance"`
}

// DecayResult is the result of a decay operation.
type DecayResult struct {
    Affected int             `json:"affected"`
    DryRun   bool            `json:"dry_run"`
    Entities []DecayedEntity `json:"entities"`
}

// SimilarPair represents two similar entities.
type SimilarPair struct {
    Entity1ID   string  `json:"entity1_id"`
    Entity1Name string  `json:"entity1_name"`
    Entity2ID   string  `json:"entity2_id"`
    Entity2Name string  `json:"entity2_name"`
    Similarity  float64 `json:"similarity"`
}

// SimilarPairsResult is the result of similar pairs detection.
type SimilarPairsResult struct {
    Pairs  []SimilarPair `json:"pairs"`
    Count  int           `json:"count"`
    DryRun bool          `json:"dry_run"` // Always true for similar (identify-only)
}
```

These types are used by both query functions and tool handlers.
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: models/reflect.go exports DecayResult, DecayedEntity, SimilarPairsResult, SimilarPair
  </verify>
  <done>
models/reflect.go created with 4 types
  </done>
</task>

<task type="auto">
  <name>Task 2: Add decay query function to db/queries.go</name>
  <files>internal/db/queries.go</files>
  <action>
Add QueryApplyDecay function to db/queries.go:

```go
// QueryApplyDecay reduces decay_weight and importance_score for entities not accessed
// within the specified number of days.
// Floor: decay_weight > 0.1 prevents complete decay.
// Returns entities affected with before/after values.
// Uses two-step approach: SELECT to capture old values, then UPDATE.
func (c *Client) QueryApplyDecay(
    ctx context.Context,
    decayDays int,
    contextFilter *string,
    global bool,
    dryRun bool,
) ([]models.DecayedEntity, error) {
    // Build context filter
    contextClause := ""
    vars := map[string]any{"decay_days": decayDays}

    if !global && contextFilter != nil {
        contextClause = "AND context = $context"
        vars["context"] = *contextFilter
    }

    // Decay factor: multiply by 0.9 (10% reduction each run)
    // Floor at 0.1 to prevent complete decay
    decayFactor := 0.9

    // Step 1: SELECT entities that would be affected (with computed new values)
    // This works for both dry_run (preview only) and apply (capture before updating)
    selectSQL := fmt.Sprintf(`
        SELECT
            id,
            content AS name,
            decay_weight AS old_decay_weight,
            math::max(decay_weight * %f, 0.1) AS new_decay_weight,
            importance AS old_importance,
            math::max(importance * %f, 0.1) AS new_importance
        FROM entity
        WHERE accessed < time::now() - duration::from::days($decay_days)
            AND decay_weight > 0.1
            %s
    `, decayFactor, decayFactor, contextClause)

    results, err := surrealdb.Query[[]models.DecayedEntity](ctx, c.db, selectSQL, vars)
    if err != nil {
        return nil, fmt.Errorf("decay select: %w", err)
    }

    var entities []models.DecayedEntity
    if results != nil && len(*results) > 0 {
        entities = (*results)[0].Result
    }

    // If dry_run, return preview without applying
    if dryRun {
        return entities, nil
    }

    // If no entities to update, return empty
    if len(entities) == 0 {
        return []models.DecayedEntity{}, nil
    }

    // Step 2: Apply UPDATE to affected entities
    updateSQL := fmt.Sprintf(`
        UPDATE entity SET
            decay_weight = math::max(decay_weight * %f, 0.1),
            importance = math::max(importance * %f, 0.1)
        WHERE accessed < time::now() - duration::from::days($decay_days)
            AND decay_weight > 0.1
            %s
    `, decayFactor, decayFactor, contextClause)

    _, err = surrealdb.Query[any](ctx, c.db, updateSQL, vars)
    if err != nil {
        return nil, fmt.Errorf("apply decay: %w", err)
    }

    return entities, nil
}
```

Key implementation details:
- Uses `duration::from::days()` for time comparison
- Decay factor 0.9 (10% reduction)
- Floor at 0.1 prevents complete decay
- Two-step approach: SELECT captures old/new values, then UPDATE applies
- Context filtering with global override
- Avoids unverified $before syntax in SurrealDB RETURN clause
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: QueryApplyDecay function exists with correct signature
  </verify>
  <done>
QueryApplyDecay added to db/queries.go
  </done>
</task>

<task type="auto">
  <name>Task 3: Add similar pairs query function to db/queries.go</name>
  <files>internal/db/queries.go</files>
  <action>
Add QueryFindSimilarPairs function to db/queries.go:

```go
// QueryFindSimilarPairs finds entity pairs with embedding similarity above threshold.
// Uses vector::similarity::cosine for comparison.
// Deduplicates pairs (returns A-B but not B-A).
// Returns at most `limit` pairs.
func (c *Client) QueryFindSimilarPairs(
    ctx context.Context,
    threshold float64,
    limit int,
    contextFilter *string,
    global bool,
) ([]models.SimilarPair, error) {
    // Build context filter for both entities in pair
    contextClause := ""
    vars := map[string]any{
        "threshold": threshold,
        "limit":     limit,
    }

    if !global && contextFilter != nil {
        contextClause = "AND e1.context = $context AND e2.context = $context"
        vars["context"] = *contextFilter
    }

    // Find similar pairs using KNN search
    // For each entity, find nearest neighbors, then filter by threshold
    // Sort pair IDs to deduplicate (e1.id < e2.id ensures A-B not B-A)
    sql := fmt.Sprintf(`
        SELECT
            e1.id AS entity1_id,
            e1.content AS entity1_name,
            e2.id AS entity2_id,
            e2.content AS entity2_name,
            vector::similarity::cosine(e1.embedding, e2.embedding) AS similarity
        FROM entity AS e1, entity AS e2
        WHERE e1.id < e2.id
            AND vector::similarity::cosine(e1.embedding, e2.embedding) >= $threshold
            %s
        ORDER BY similarity DESC
        LIMIT $limit
    `, contextClause)

    results, err := surrealdb.Query[[]models.SimilarPair](ctx, c.db, sql, vars)
    if err != nil {
        return nil, fmt.Errorf("find similar pairs: %w", err)
    }

    if results == nil || len(*results) == 0 {
        return []models.SimilarPair{}, nil
    }
    return (*results)[0].Result, nil
}
```

Key implementation details:
- Uses `vector::similarity::cosine()` for semantic comparison
- `e1.id < e2.id` ensures each pair appears once (no duplicates)
- Context filtering applies to both entities
- Ordered by similarity descending (most similar first)
- Limit controls max pairs returned
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: QueryFindSimilarPairs function exists with correct signature
  </verify>
  <done>
QueryFindSimilarPairs added to db/queries.go
  </done>
</task>

<task type="auto">
  <name>Task 4: Create reflect.go with tool handler</name>
  <files>internal/tools/reflect.go</files>
  <action>
Create internal/tools/reflect.go with the reflect tool handler:

```go
package tools

import (
    "context"
    "encoding/json"

    "github.com/modelcontextprotocol/go-sdk/mcp"
    "github.com/raphaelgruber/memcp-go/internal/config"
    "github.com/raphaelgruber/memcp-go/internal/models"
)

// ReflectInput defines the input schema for the reflect tool.
type ReflectInput struct {
    Action              string  `json:"action" jsonschema:"required,enum=decay|similar,Maintenance action: 'decay' reduces scores for stale entities, 'similar' finds potential duplicates"`
    DryRun              bool    `json:"dry_run,omitempty" jsonschema:"Preview changes without applying (default: false)"`
    Context             string  `json:"context,omitempty" jsonschema:"Project namespace filter (auto-detected if omitted)"`
    Global              bool    `json:"global,omitempty" jsonschema:"Apply to all contexts (default: false)"`
    // Decay-specific
    DecayDays           int     `json:"decay_days,omitempty" jsonschema:"Days of inactivity before decay applies (default: 30)"`
    // Similar-specific
    SimilarityThreshold float64 `json:"similarity_threshold,omitempty" jsonschema:"Minimum similarity score 0.0-1.0 (default: 0.85)"`
    Limit               int     `json:"limit,omitempty" jsonschema:"Max similar pairs to return (default: 10)"`
}

// ReflectResult wraps the action-specific result.
type ReflectResult struct {
    Action string `json:"action"`
    Decay  *models.DecayResult       `json:"decay,omitempty"`
    Similar *models.SimilarPairsResult `json:"similar,omitempty"`
}

// NewReflectHandler creates the reflect tool handler.
// Supports maintenance actions: decay (reduce stale entity scores) and similar (find duplicates).
func NewReflectHandler(deps *Dependencies, cfg *config.Config) mcp.ToolHandlerFor[ReflectInput, any] {
    return func(ctx context.Context, req *mcp.CallToolRequest, input ReflectInput) (
        *mcp.CallToolResult, any, error,
    ) {
        // Validate action
        if input.Action != "decay" && input.Action != "similar" {
            return ErrorResult("Invalid action", "Use 'decay' or 'similar'"), nil, nil
        }

        // Detect context: explicit > config
        var contextFilter *string
        if input.Context != "" {
            contextFilter = &input.Context
        } else if !input.Global {
            contextFilter = DetectContext(cfg)
        }

        switch input.Action {
        case "decay":
            return handleDecay(ctx, deps, input, contextFilter)
        case "similar":
            return handleSimilar(ctx, deps, input, contextFilter)
        default:
            return ErrorResult("Unknown action", "Use 'decay' or 'similar'"), nil, nil
        }
    }
}

// handleDecay applies decay to stale entities.
func handleDecay(
    ctx context.Context,
    deps *Dependencies,
    input ReflectInput,
    contextFilter *string,
) (*mcp.CallToolResult, any, error) {
    // Set defaults
    decayDays := input.DecayDays
    if decayDays <= 0 {
        decayDays = 30
    }

    // Query decay
    entities, err := deps.DB.QueryApplyDecay(ctx, decayDays, contextFilter, input.Global, input.DryRun)
    if err != nil {
        deps.Logger.Error("reflect decay failed", "error", err)
        return ErrorResult("Failed to apply decay", "Database may be unavailable"), nil, nil
    }

    // Build result
    decayResult := &models.DecayResult{
        Affected: len(entities),
        DryRun:   input.DryRun,
        Entities: entities,
    }

    result := ReflectResult{
        Action: "decay",
        Decay:  decayResult,
    }

    jsonBytes, _ := json.MarshalIndent(result, "", "  ")

    action := "applied"
    if input.DryRun {
        action = "previewed"
    }
    deps.Logger.Info("reflect decay completed", "action", action, "affected", len(entities), "decay_days", decayDays)
    return TextResult(string(jsonBytes)), nil, nil
}

// handleSimilar finds similar entity pairs.
func handleSimilar(
    ctx context.Context,
    deps *Dependencies,
    input ReflectInput,
    contextFilter *string,
) (*mcp.CallToolResult, any, error) {
    // Set defaults
    threshold := input.SimilarityThreshold
    if threshold <= 0 {
        threshold = 0.85
    }
    if threshold > 1.0 {
        threshold = 1.0
    }

    limit := input.Limit
    if limit <= 0 {
        limit = 10
    }
    if limit > 50 {
        limit = 50
    }

    // Query similar pairs
    pairs, err := deps.DB.QueryFindSimilarPairs(ctx, threshold, limit, contextFilter, input.Global)
    if err != nil {
        deps.Logger.Error("reflect similar failed", "error", err)
        return ErrorResult("Failed to find similar pairs", "Database may be unavailable"), nil, nil
    }

    // Build result (always dry_run=true since similar is identify-only)
    similarResult := &models.SimilarPairsResult{
        Pairs:  pairs,
        Count:  len(pairs),
        DryRun: true,
    }

    result := ReflectResult{
        Action:  "similar",
        Similar: similarResult,
    }

    jsonBytes, _ := json.MarshalIndent(result, "", "  ")

    deps.Logger.Info("reflect similar completed", "pairs_found", len(pairs), "threshold", threshold)
    return TextResult(string(jsonBytes)), nil, nil
}
```

Key implementation details:
- Single tool with action enum (decay | similar)
- Context detection follows established pattern (explicit > config > auto)
- Global flag overrides context filtering
- Decay defaults: 30 days, applies unless dry_run=true
- Similar defaults: 0.85 threshold, limit 10, max 50
- Similar is always identify-only (dry_run forced true in result)
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Check: reflect.go exports NewReflectHandler
  </verify>
  <done>
reflect.go created with handler and input/result types
  </done>
</task>

<task type="auto">
  <name>Task 5: Register reflect tool in registry.go</name>
  <files>internal/tools/registry.go</files>
  <action>
Update RegisterAll() in registry.go to register the reflect tool.

Add after existing procedure tools (list_procedures):

```go
// Reflect tool - memory maintenance operations
mcp.AddTool(server, &mcp.Tool{
    Name:        "reflect",
    Description: "Maintain memory store health: 'decay' reduces importance of unused entities, 'similar' identifies potential duplicates for manual review",
}, NewReflectHandler(deps, cfg))
```
  </action>
  <verify>
Run: `go build ./...` - compiles without errors
Run: Check via MCP inspector - should list 19 tools total
  </verify>
  <done>
reflect tool registered in registry.go
Total tools: 19 (18 existing + 1 new)
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./...` passes (existing tests)
3. Manual verification: Start server, use MCP inspector to:
   - Call reflect with action="decay", dry_run=true - shows entities that would be affected
   - Call reflect with action="decay", dry_run=false - applies decay to stale entities
   - Call reflect with action="similar" - returns pairs with similarity >= 0.85
   - Call reflect with action="similar", similarity_threshold=0.9 - returns higher threshold matches
   - Verify global=true bypasses context filtering
</verification>

<success_criteria>
- [ ] models/reflect.go with DecayResult, DecayedEntity, SimilarPairsResult, SimilarPair
- [ ] QueryApplyDecay in db/queries.go with dry_run support
- [ ] QueryFindSimilarPairs in db/queries.go with deduplication
- [ ] reflect.go with NewReflectHandler supporting action=decay and action=similar
- [ ] reflect tool registered in registry.go
- [ ] `go build ./...` passes
- [ ] action=decay reduces decay_weight and importance for stale entities
- [ ] action=similar finds pairs with cosine similarity above threshold
</success_criteria>

<output>
After completion, create `.planning/phases/08-maintenance-tools/08-01-SUMMARY.md`
</output>
