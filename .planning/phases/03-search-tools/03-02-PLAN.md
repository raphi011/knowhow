---
phase: 03-search-tools
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/tools/search.go
  - internal/tools/registry.go
  - internal/tools/search_test.go
autonomous: true

must_haves:
  truths:
    - "get_entity retrieves entity by ID with full details"
    - "get_entity returns not found error for invalid ID"
    - "list_labels returns all unique labels with counts"
    - "list_types returns all entity types with counts"
  artifacts:
    - path: "internal/tools/search.go"
      provides: "All search-related tool handlers"
      exports: ["NewSearchHandler", "NewGetEntityHandler", "NewListLabelsHandler", "NewListTypesHandler"]
  key_links:
    - from: "internal/tools/search.go (GetEntity)"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryGetEntity call"
      pattern: "deps\\.DB\\.QueryGetEntity"
    - from: "internal/tools/search.go (ListLabels)"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryListLabels call"
      pattern: "deps\\.DB\\.QueryListLabels"
---

<objective>
Implement get_entity, list_labels, and list_types tools to complete the search toolkit.

Purpose: Enable entity retrieval by ID and metadata browsing for knowledge exploration
Output: Three additional tools for precise entity access and taxonomy navigation
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-tools/03-RESEARCH.md
@.planning/phases/03-search-tools/03-01-SUMMARY.md

# Existing code from Plan 01
@internal/db/queries.go
@internal/tools/search.go
@internal/tools/context.go
@internal/tools/registry.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement get_entity Tool</name>
  <files>internal/tools/search.go, internal/tools/registry.go</files>
  <action>
**internal/tools/search.go** - Add get_entity handler:

GetEntityInput struct:
- ID string `json:"id" jsonschema:"required,The entity ID to retrieve"`

NewGetEntityHandler(deps *Dependencies) (no cfg needed - no context detection):
1. Validate: ID cannot be empty -> ErrorResult("ID cannot be empty", "Provide an entity ID")
2. Extract ID: extractID(input.ID) to handle "entity:xxx" or "xxx"
3. Query: deps.DB.QueryGetEntity(ctx, id)
4. Handle nil result: ErrorResult("Entity not found: {id}", "Use search to find valid IDs")
5. Update access: deps.DB.QueryUpdateAccess(ctx, id)
6. Format as JSON: json.MarshalIndent(entity, "", "  ")
7. Log: "get_entity completed" with id

**internal/tools/registry.go** - Add registration:

```go
mcp.AddTool(server, &mcp.Tool{
    Name:        "get_entity",
    Description: "Retrieve an entity by its ID with full details",
}, NewGetEntityHandler(deps))
```
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...
```
  </verify>
  <done>get_entity tool compiles and is registered</done>
</task>

<task type="auto">
  <name>Task 2: Implement list_labels and list_types Tools</name>
  <files>internal/tools/search.go, internal/tools/registry.go</files>
  <action>
**internal/tools/search.go** - Add both handlers:

**ListLabelsInput struct:**
- Context string `json:"context,omitempty" jsonschema:"Optional project namespace filter"`

**NewListLabelsHandler(deps *Dependencies, cfg *config.Config):**
1. Detect context: explicit input.Context > DetectContext(cfg)
2. Query: deps.DB.QueryListLabels(ctx, contextPtr)
3. Format as JSON array of {label, count}
4. Log: "list_labels completed" with count

**ListTypesInput struct:**
- Context string `json:"context,omitempty" jsonschema:"Optional project namespace filter"`

**NewListTypesHandler(deps *Dependencies, cfg *config.Config):**
1. Detect context: explicit input.Context > DetectContext(cfg)
2. Query: deps.DB.QueryListTypes(ctx, contextPtr)
3. Format as JSON array of {type, count}
4. Log: "list_types completed" with count

**internal/tools/registry.go** - Add registrations:

```go
mcp.AddTool(server, &mcp.Tool{
    Name:        "list_labels",
    Description: "List all unique labels with entity counts",
}, NewListLabelsHandler(deps, cfg))

mcp.AddTool(server, &mcp.Tool{
    Name:        "list_types",
    Description: "List all entity types with counts",
}, NewListTypesHandler(deps, cfg))
```
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...
```
  </verify>
  <done>list_labels and list_types tools compile and are registered</done>
</task>

<task type="auto">
  <name>Task 3: Add Integration Tests</name>
  <files>internal/tools/search_test.go</files>
  <action>
Extend internal/tools/search_test.go with tests for new tools:

**TestAllSearchToolsRegistered:**
- Verify all 4 tools appear in tools/list: search, get_entity, list_labels, list_types

**TestGetEntityValidation:**
- Empty ID returns error with "ID cannot be empty"

**TestListLabelsEmptyResult:**
- With nil deps (validation only), no panic on empty database
- Actually this needs real deps... mark as integration test comment

Update existing tests if needed for new RegisterAll signature.

Pattern from tools_test.go:
```go
func TestAllSearchToolsRegistered(t *testing.T) {
    clientT, serverT := mcp.NewInMemoryTransport()
    srv := server.New()
    srv.Setup()

    // RegisterAll with nil deps and nil cfg for validation
    tools.RegisterAll(srv.MCPServer(), nil, nil)

    go srv.MCPServer().Run(context.Background(), serverT)

    client := mcp.NewClient(nil)
    client.Start(context.Background(), clientT)

    result, err := client.ListTools(context.Background(), nil)
    require.NoError(t, err)

    toolNames := make([]string, len(result.Tools))
    for i, tool := range result.Tools {
        toolNames[i] = tool.Name
    }

    assert.Contains(t, toolNames, "search")
    assert.Contains(t, toolNames, "get_entity")
    assert.Contains(t, toolNames, "list_labels")
    assert.Contains(t, toolNames, "list_types")
}
```

Add comment at top of test file:
```go
// Integration tests requiring SurrealDB/Ollama are in test_integration.go
```
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go test ./internal/tools/... -v
```
  </verify>
  <done>All 4 search tools appear in tools list, validation tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build passes
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...

# All tests pass
go test ./... -v

# All 4 tools registered
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | timeout 2 go run ./cmd/memcp 2>/dev/null | grep -E "(search|get_entity|list_labels|list_types)"
```
</verification>

<success_criteria>
- get_entity, list_labels, list_types handlers in search.go
- All 4 tools registered in registry.go
- Tests verify all tools appear in list
- Validation tests for empty ID
- go test ./... passes
- go build ./... succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-tools/03-02-SUMMARY.md`
</output>
