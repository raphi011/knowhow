---
phase: 03-search-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/queries.go
  - internal/tools/search.go
  - internal/tools/context.go
  - internal/tools/registry.go
autonomous: true

must_haves:
  truths:
    - "search tool returns ranked entities for semantic query"
    - "search generates embedding from query text via Ollama"
    - "search applies RRF fusion of BM25 + vector results"
    - "access tracking updates accessed timestamp and count"
  artifacts:
    - path: "internal/db/queries.go"
      provides: "Query functions for search operations"
      exports: ["QueryHybridSearch", "QueryGetEntity", "QueryUpdateAccess", "QueryListLabels", "QueryListTypes"]
    - path: "internal/tools/search.go"
      provides: "Search tool handler"
      exports: ["NewSearchHandler", "SearchInput"]
    - path: "internal/tools/context.go"
      provides: "Context detection helpers"
      exports: ["DetectContext"]
  key_links:
    - from: "internal/tools/search.go"
      to: "internal/db/queries.go"
      via: "deps.DB.QueryHybridSearch call"
      pattern: "deps\\.DB\\.QueryHybridSearch"
    - from: "internal/tools/search.go"
      to: "internal/embedding/embedder.go"
      via: "deps.Embedder.Embed call"
      pattern: "deps\\.Embedder\\.Embed"
---

<objective>
Implement the search tool with hybrid BM25 + vector search using SurrealDB's search::rrf() function.

Purpose: Enable semantic search across the knowledge graph with proper relevance ranking
Output: Working search tool that agents can use to find relevant entities
</objective>

<execution_context>
@/Users/raphaelgruber/.claude/get-shit-done/workflows/execute-plan.md
@/Users/raphaelgruber/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-tools/03-RESEARCH.md
@.planning/phases/02-mcp-server/02-02-SUMMARY.md

# Existing code to extend
@internal/db/client.go
@internal/tools/deps.go
@internal/tools/errors.go
@internal/tools/ping.go
@internal/tools/registry.go
@internal/models/entity.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Query Functions Layer</name>
  <files>internal/db/queries.go</files>
  <action>
Create internal/db/queries.go with typed query functions:

1. **QueryHybridSearch** - RRF fusion of BM25 + vector search:
   - Parameters: ctx, query string, embedding []float32, labels []string, limit int, context *string
   - Build dynamic filter clauses for labels (CONTAINSANY) and context (=)
   - Use search::rrf() with limit*2 for vector (more variety), limit for final
   - Vector query: `embedding <|{limit*2},40|> $emb` (HNSW with ef=40)
   - BM25 query: `content @0@ $q` (full-text search analyzer 0)
   - RRF k parameter: 60 (standard constant)
   - Return []models.Entity, handle nil/empty results gracefully
   - Use `surrealdb.Query[[]models.Entity]` then extract `(*results)[0].Result`

2. **QueryGetEntity** - Get entity by ID:
   - Parameters: ctx, id string
   - Use `type::record("entity", $id)` to handle both "entity:xxx" and "xxx" formats
   - Return *models.Entity (nil if not found), nil error

3. **QueryUpdateAccess** - Update access tracking:
   - Parameters: ctx, id string
   - UPDATE entity SET accessed = time::now(), access_count += 1, decay_weight = 1.0
   - Return error only

4. **QueryListLabels** - Get unique labels with counts:
   - Parameters: ctx, context *string (optional filter)
   - Use GROUP BY labels with COUNT()
   - Return []LabelCount{Label string, Count int}

5. **QueryListTypes** - Get entity types with counts:
   - Parameters: ctx, context *string (optional filter)
   - GROUP BY type with COUNT()
   - Return []TypeCount{Type string, Count int}

Helper types (add at top of file):
```go
type LabelCount struct {
    Label string `json:"label"`
    Count int    `json:"count"`
}

type TypeCount struct {
    Type  string `json:"type"`
    Count int    `json:"count"`
}
```

Key patterns from research:
- Always check `results != nil && len(*results) > 0` before accessing
- Dynamic SQL building with fmt.Sprintf for filter clauses
- Pass nil-safe vars map even when context is nil
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...
```
  </verify>
  <done>All 5 query functions compile, follow established Client method pattern</done>
</task>

<task type="auto">
  <name>Task 2: Implement Search Tool Handler</name>
  <files>internal/tools/search.go, internal/tools/context.go, internal/tools/registry.go</files>
  <action>
**internal/tools/context.go** - Context detection helpers:

Create DetectContext function:
```go
func DetectContext(cfg *config.Config) *string
```

Priority order:
1. If cfg.DefaultContext != "" -> return &cfg.DefaultContext
2. If !cfg.ContextFromCWD -> return nil (detection disabled)
3. Try git origin: run `git config --get remote.origin.url`, parse repo name
4. Fall back to cwd basename: filepath.Base(os.Getwd())

Helper for git origin parsing - extract repo name from:
- `git@github.com:owner/repo.git` -> "repo"
- `https://github.com/owner/repo.git` -> "repo"
- `https://github.com/owner/repo` -> "repo"

Add extractID helper:
```go
func extractID(id string) string {
    return strings.TrimPrefix(id, "entity:")
}
```

**internal/tools/search.go** - Search tool handler:

SearchInput struct:
- Query string `json:"query" jsonschema:"required,The search query text"`
- Labels []string `json:"labels,omitempty" jsonschema:"Optional label filter"`
- Limit int `json:"limit,omitempty" jsonschema:"Max results 1-100, default 10"`
- Context string `json:"context,omitempty" jsonschema:"Project namespace filter"`

NewSearchHandler(deps *Dependencies, cfg *config.Config) pattern:
1. Validate: Query cannot be empty -> ErrorResult
2. Validate: Limit 1-100, default 10 -> ErrorResult if > 100
3. Generate embedding: deps.Embedder.Embed(ctx, input.Query)
4. Detect context: explicit input.Context > DetectContext(cfg)
5. Execute: deps.DB.QueryHybridSearch(ctx, query, embedding, labels, limit, contextPtr)
6. Update access for each result: deps.DB.QueryUpdateAccess(ctx, extractID(e.ID))
7. Format as JSON: models.SearchResult{Entities, Count}
8. Log: "search completed" with query (truncated 30 chars), result count

Note: Handler factory takes TWO params: deps *Dependencies, cfg *config.Config

**internal/tools/registry.go** - Add search tool:

Update RegisterAll to also accept cfg *config.Config:
```go
func RegisterAll(server *mcp.Server, deps *Dependencies, cfg *config.Config)
```

Add search tool registration after ping:
```go
mcp.AddTool(server, &mcp.Tool{
    Name:        "search",
    Description: "Search the knowledge graph using hybrid BM25 + vector search with RRF fusion",
}, NewSearchHandler(deps, cfg))
```
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...
```
  </verify>
  <done>Search tool registered, compiles, follows handler factory pattern from 02-02</done>
</task>

<task type="auto">
  <name>Task 3: Update Main and Add Integration Test</name>
  <files>cmd/memcp/main.go, internal/tools/search_test.go</files>
  <action>
**cmd/memcp/main.go**:

Update RegisterAll call to pass cfg:
```go
tools.RegisterAll(srv.MCPServer(), deps, &cfg)  // Add cfg parameter
```

**internal/tools/search_test.go** - Integration test:

Create test that verifies search tool registration and basic invocation:

```go
func TestSearchToolRegistered(t *testing.T) {
    // Create in-memory transport like tools_test.go
    // Verify "search" appears in tools/list
}

func TestSearchToolValidation(t *testing.T) {
    // Test empty query returns error
    // Test limit > 100 returns error
}
```

Use same pattern as internal/tools/tools_test.go:
- In-memory transport with mcp.NewInMemoryTransport()
- Create server via server.New()
- Register tools with nil deps (validation only, no DB calls)
- Use client to list tools and verify search exists

Skip actual search execution tests (require running SurrealDB + Ollama).
Add comment: `// Integration tests with real DB in test_integration.go`
  </action>
  <verify>
```bash
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go test ./internal/tools/... -v
```
  </verify>
  <done>Main compiles, search tool appears in tools list, validation tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build passes
cd /Users/raphaelgruber/Git/memcp/migrate-to-go && go build ./...

# Tests pass
go test ./... -v

# Search tool appears in list (run server briefly)
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | timeout 2 go run ./cmd/memcp 2>/dev/null | grep -q "search" && echo "search tool registered"
```
</verification>

<success_criteria>
- internal/db/queries.go has 5 typed query functions
- internal/tools/search.go has SearchInput + NewSearchHandler
- internal/tools/context.go has DetectContext + extractID
- Search tool registered in registry
- Main passes cfg to RegisterAll
- All tests pass
- go build ./... succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-tools/03-01-SUMMARY.md`
</output>
